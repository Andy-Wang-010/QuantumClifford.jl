<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumClifford.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumClifford.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumClifford.jl</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../canonicalization/">Canonicalization</a></li><li><a class="tocitem" href="../mixed/">Mixed States</a></li><li><a class="tocitem" href="../graphs/">Graph States</a></li><li><a class="tocitem" href="../datastructures/">Datastructure Choice</a></li><li><a class="tocitem" href="../commonstates/">Useful States and Operators</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#States"><span>States</span></a></li><li><a class="tocitem" href="#all-operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Autogenerated-API-list"><span>Autogenerated API list</span></a></li></ul></li><li><a class="tocitem" href="../tutandpub/">Tutorials and Publications</a></li><li><span class="tocitem">Noisy Circuits</span><ul><li><a class="tocitem" href="../noisycircuits/">Simulation of Noisy Circuits</a></li><li><a class="tocitem" href="../noisycircuits_mc/">Monte Carlo</a></li><li><a class="tocitem" href="../noisycircuits_perturb/">Perturbative Expansions</a></li><li><a class="tocitem" href="../noisycircuits_ops/">Circuit Operations</a></li><li><a class="tocitem" href="../noisycircuits_API/">API</a></li></ul></li><li><a class="tocitem" href="../references/">Suggested Readings &amp; References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Krastanov/QuantumClifford.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-API"><a class="docs-heading-anchor" href="#Full-API">Full API</a><a id="Full-API-1"></a><a class="docs-heading-anchor-permalink" href="#Full-API" title="Permalink"></a></h1><style>
    .content table td {
        padding-top: 0 !important;
        padding-bottom: 0 !important;
    }
</style><h2 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h2><p>Stabilizer states can be represented with the <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a>, <a href="#QuantumClifford.Destabilizer"><code>Destabilizer</code></a>, <a href="#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a>, and <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> tableau data structures. You probably want to use <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> which supports the widest set of operations.</p><p>Moreover, a <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> can be stored inside a <a href="#QuantumClifford.Register"><code>Register</code></a> together with a set of classical bits in which measurement results can be written.</p><p>There are <a href="../commonstates/#Useful-States-and-Operators">convenience constructors for common types of states and operators</a>.</p><h2 id="all-operations"><a class="docs-heading-anchor" href="#all-operations">Operations</a><a id="all-operations-1"></a><a class="docs-heading-anchor-permalink" href="#all-operations" title="Permalink"></a></h2><p>All of these can be applied on a state with the <a href="@ref"><code>apply!</code></a> function. Whether they are deterministic and their computational complexity is listed in the table below. A list of lower-level functions for more control over how an operation is performed is also given.</p><table><tr><th style="text-align: left">Type</th><th style="text-align: center">Deterministic</th><th style="text-align: right">𝒪(nˣ)</th><th style="text-align: right">Low-level functions</th></tr><tr><td style="text-align: left"><code>AbstractOperation</code></td><td style="text-align: center"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>├─ AbstractCliffordOperator</code></td><td style="text-align: center"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   ├─ AbstractSymbolicOperator</code></td><td style="text-align: center"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   ├─ AbstractSingleQubitOperator</code></td><td style="text-align: center"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   │   ├─ SingleQubitOperator</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   │   ├─ sHadamard</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   │   ├─ sId1</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   │   ├─ sInvPhase</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   │   ├─ sPhase</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   │   ├─ sX</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   │   ├─ sY</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   │   └─ sZ</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │   └─ AbstractTwoQubitOperator</code></td><td style="text-align: center"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │       ├─ sCNOT</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │       ├─ sCPHASE</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │       └─ sSWAP</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   │</code></td><td style="text-align: center"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   ├─ CliffordOperator</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n³</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   ├─ PauliOperator</code></td><td style="text-align: center">✔️</td><td style="text-align: right">n²</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   └─ SparseGate</code></td><td style="text-align: center">✔️</td><td style="text-align: right">kn²</td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>├─ AbstractMeasurement</code></td><td style="text-align: center"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>│   ├─ PauliMeasurement</code></td><td style="text-align: center">❌</td><td style="text-align: right">n²</td><td style="text-align: right"><a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>projectrand!</code></a></td></tr><tr><td style="text-align: left"><code>│   ├─ sMX</code></td><td style="text-align: center">❌</td><td style="text-align: right">n²</td><td style="text-align: right"><a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a></td></tr><tr><td style="text-align: left"><code>│   ├─ sMY</code></td><td style="text-align: center">❌</td><td style="text-align: right">n²</td><td style="text-align: right"><a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a></td></tr><tr><td style="text-align: left"><code>│   └─ sMZ</code></td><td style="text-align: center">❌</td><td style="text-align: right">n²</td><td style="text-align: right"><a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a></td></tr><tr><td style="text-align: left"><code>│</code></td><td style="text-align: center"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>└─ Reset</code></td><td style="text-align: center">✔️</td><td style="text-align: right">kn²</td><td style="text-align: right"><a href="#QuantumInterface.reset_qubits!-Tuple{MixedDestabilizer, QuantumClifford.AbstractStabilizer, Any}"><code>reset_qubits!</code></a></td></tr></table><h2 id="Autogenerated-API-list"><a class="docs-heading-anchor" href="#Autogenerated-API-list">Autogenerated API list</a><a id="Autogenerated-API-list-1"></a><a class="docs-heading-anchor-permalink" href="#Autogenerated-API-list" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.QuantumClifford" href="#QuantumClifford.QuantumClifford"><code>QuantumClifford.QuantumClifford</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A module for using the Stabilizer formalism and simulating Clifford circuits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.AbstractSingleQubitOperator" href="#QuantumClifford.AbstractSingleQubitOperator"><code>QuantumClifford.AbstractSingleQubitOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of all single-qubit symbolic operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.AbstractSymbolicOperator" href="#QuantumClifford.AbstractSymbolicOperator"><code>QuantumClifford.AbstractSymbolicOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of all symbolic operators. Subtype of <code>AbstractCliffordOperator</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.AbstractTwoQubitOperator" href="#QuantumClifford.AbstractTwoQubitOperator"><code>QuantumClifford.AbstractTwoQubitOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of all two-qubit symbolic operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.CliffordOperator" href="#QuantumClifford.CliffordOperator"><code>QuantumClifford.CliffordOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Clifford Operator specified by the mapping of the basis generators.</p><pre><code class="language-julia-repl hljs">julia&gt; tCNOT
X_ ⟼ + XX
_X ⟼ + _X
Z_ ⟼ + Z_
_Z ⟼ + ZZ

julia&gt; phase_gate = C&quot;Y
                      Z&quot;
X ⟼ + Y
Z ⟼ + Z

julia&gt; stab = S&quot;XI
                IZ&quot;;

julia&gt; entangled = tCNOT*stab
+ XX
+ ZZ</code></pre><p>julia&gt; CliffordOperator(T&quot;YY&quot;) ERROR: DimensionMismatch(&quot;Input tableau should be square (in which case the destabilizers are calculated) or of size 2n×n (in which case it is used directly).&quot;) [...]</p><pre><code class="nohighlight hljs">
[`Destabilizer`](@ref) can also be converted.</code></pre><p>jldoctest julia&gt; d = Destabilizer(S&quot;Y&quot;)</p><ul><li>Z</li></ul><p>━━━</p><ul><li>Y</li></ul><p>julia&gt; CliffordOperator(d) X ⟼ + Z Z ⟼ + Y ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/dense_cliffords.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.Destabilizer" href="#QuantumClifford.Destabilizer"><code>QuantumClifford.Destabilizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A tableau representation of a pure stabilizer state. The tableau tracks the destabilizers as well, for efficient projections. On initialization there are no checks that the provided state is indeed pure. This enables the use of this data structure for mixed stabilizer state, but a better choice would be to use <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L542-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.MixedDestabilizer" href="#QuantumClifford.MixedDestabilizer"><code>QuantumClifford.MixedDestabilizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A tableau representation for mixed stabilizer states that keeps track of the destabilizers in order to provide efficient projection operations.</p><p>The rank <code>r</code> of the <code>n</code>-qubit tableau is tracked, either so that it can be used to represent a mixed stabilizer state, or so that it can be used to represent an <code>n-r</code> logical-qubit code over <code>n</code> physical qubits. The &quot;logical&quot; operators are tracked as well.</p><p>When the constructor is called on an incomplete <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a> it automatically calculates the destabilizers and logical operators, following chapter 4 of <a href="../references/#gottesman1997stabilizer">Daniel Gottesman (1997)</a>.</p><p>See also: <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L607-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.MixedStabilizer" href="#QuantumClifford.MixedStabilizer"><code>QuantumClifford.MixedStabilizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A slight improvement of the <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a> data structure that enables more naturally and completely the treatment of mixed states, in particular when the <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a> function is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L575-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.PauliMeasurement" href="#QuantumClifford.PauliMeasurement"><code>QuantumClifford.PauliMeasurement</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Stabilizer measurement on the entirety of the quantum register.</p><p><code>projectrand!(state, pauli)</code> and <code>apply!(state, PauliMeasurement(pauli))</code> give the same (possibly non-deterministic) result. Particularly useful when acting on <a href="#QuantumClifford.Register"><code>Register</code></a>.</p><p>See also: <a href="@ref"><code>apply!</code></a>, <a href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>projectrand!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/misc_ops.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.PauliOperator" href="#QuantumClifford.PauliOperator"><code>QuantumClifford.PauliOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A multi-qubit Pauli operator (<span>$±\{1,i\}\{I,Z,X,Y\}^{\otimes n}$</span>).</p><p>A Pauli can be constructed with the <code>P</code> custom string macro or by building up one through products and tensor products of smaller operators.</p><pre><code class="language-julia-repl hljs">julia&gt; pauli3 = P&quot;-iXYZ&quot;
-iXYZ

julia&gt; pauli4 = 1im * pauli3 ⊗ X
+ XYZX

julia&gt; Z*X
+iY</code></pre><p>We use a typical F(2,2) encoding internally. The X and Z bits are stored in a single concatenated padded array of UInt chunks of a bit array.</p><pre><code class="language-julia-repl hljs">julia&gt; p = P&quot;-IZXY&quot;;

julia&gt; p.xz
2-element Vector{UInt64}:
 0x000000000000000c
 0x000000000000000a</code></pre><p>You can access the X and Z bits through getters and setters or through the <code>xview</code>, <code>zview</code>, <code>xbit</code>, and <code>zbit</code> functions.</p><pre><code class="language-julia-repl hljs">julia&gt; p = P&quot;XYZ&quot;; p[1]
(true, false)

julia&gt; p[1] = (true, true); p
+ YYZ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L81-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.Register" href="#QuantumClifford.Register"><code>QuantumClifford.Register</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A register, representing the state of a computer including both a tableaux and an array of classical bits (e.g. for storing measurement results)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/classical_register.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.Reset" href="#QuantumClifford.Reset"><code>QuantumClifford.Reset</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Reset the specified qubits to the given state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/misc_ops.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.SingleQubitOperator" href="#QuantumClifford.SingleQubitOperator"><code>QuantumClifford.SingleQubitOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; general single-qubit operator which permits faster multiplication than an operator expressed as an explicit tableau.</p><pre><code class="language-julia-repl hljs">julia&gt; op = SingleQubitOperator(2, true, true, true, false, true, true) # Tableau components and phases
Symbolic single-qubit gate on qubit 2
X ⟼ - Y
Z ⟼ - X

julia&gt; typeof(op)
SingleQubitOperator

julia&gt; t_op = CliffordOperator(op, 3) # Transforming it back into an explicit tableau representation (specifying the size)
X__ ⟼ + X__
_X_ ⟼ - _Y_
__X ⟼ + __X
Z__ ⟼ + Z__
_Z_ ⟼ - _X_
__Z ⟼ + __Z

julia&gt; typeof(t_op)
CliffordOperator{QuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}}

julia&gt; CliffordOperator(op, 1, compact=true) # You can also extract just the non-trivial part of the tableau
X ⟼ - Y
Z ⟼ - X</code></pre><p>See also: <a href="#QuantumClifford.sHadamard"><code>sHadamard</code></a>, <a href="#QuantumClifford.sPhase"><code>sPhase</code></a>, <a href="#QuantumClifford.sId1"><code>sId1</code></a>, <a href="#QuantumClifford.sX"><code>sX</code></a>, <a href="#QuantumClifford.sY"><code>sY</code></a>, <a href="#QuantumClifford.sZ"><code>sZ</code></a>, <a href="#QuantumClifford.CliffordOperator"><code>CliffordOperator</code></a></p><p>Or simply consult <code>subtypes(QuantumClifford.AbstractSingleQubitOperator)</code> and <code>subtypes(QuantumClifford.AbstractTwoQubitOperator)</code> for a full list. You can think of the <code>s</code> prefix as &quot;symbolic&quot; or &quot;sparse&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L94-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.SparseGate" href="#QuantumClifford.SparseGate"><code>QuantumClifford.SparseGate</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Clifford gate, applying the given <code>cliff</code> operator to the qubits at the selected <code>indices</code>.</p><p><code>apply!(state, cliff, indices)</code> and <code>apply!(state, SparseGate(cliff, indices))</code> give the same result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/misc_ops.jl#L19-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.Stabilizer" href="#QuantumClifford.Stabilizer"><code>QuantumClifford.Stabilizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stabilizer, i.e. a list of commuting multi-qubit Hermitian Pauli operators.</p><p>Instances can be created with the <code>S</code> custom string macro or as direct sum of other stabilizers.</p><div class="admonition is-success"><header class="admonition-header">Stabilizers and Destabilizers</header><div class="admonition-body"><p>In many cases you probably would prefer to use the <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> data structure, as it caries a lot of useful additional information, like tracking rank and destabilizer operators. <code>Stabilizer</code> has mostly a pedagogical value, and it is also used for slightly faster simulation of a particular subset of Clifford operations.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;XXX
             ZZI
             IZZ&quot;
+ XXX
+ ZZ_
+ _ZZ

julia&gt; s⊗s
+ XXX___
+ ZZ____
+ _ZZ___
+ ___XXX
+ ___ZZ_
+ ____ZZ</code></pre><p>It has an indexing API, looking like a list of <code>PauliOperator</code>s.</p><pre><code class="language-julia-repl hljs">julia&gt; s[2]
+ ZZ_</code></pre><p>Pauli operators can act directly on the a stabilizer.</p><pre><code class="language-julia-repl hljs">julia&gt; P&quot;YYY&quot; * s
- XXX
+ ZZ_
+ _ZZ</code></pre><p>There are a number of ways to create a Stabilizer, including:</p><ul><li>generate Stabilizers from a list of Pauli operators</li></ul><pre><code class="language-julia-repl hljs">julia&gt; Stabilizer([P&quot;XX&quot;, P&quot;ZZ&quot;])
+ XX
+ ZZ</code></pre><ul><li>generate Stabilizers from boolean matrices</li></ul><pre><code class="language-julia-repl hljs">julia&gt; a = [true true; false false]; b = [false true; true true];

julia&gt; Stabilizer(a, b)
+ XY
+ ZZ

julia&gt; Stabilizer([0x0, 0x2], a, b)
+ XY
- ZZ</code></pre><ul><li>initialize an empty Stabilizer and fill it through indexing</li></ul><pre><code class="language-julia-repl hljs">julia&gt; s = zero(Stabilizer, 2)
+ __
+ __

julia&gt; s[1,1] = (true, false); s
+ X_
+ __</code></pre><p>There are no automatic checks for correctness (i.e. independence of all rows, commutativity of all rows, hermiticity of all rows). The rank (number of rows) is permitted to be less than the number of qubits (number of columns): canonilization, projection, etc. continue working in that case. To great extent this library uses the <code>Stabilizer</code> data structure simply as a tableau. This might be properly abstracted away in future versions.</p><p>See also: <a href="#QuantumClifford.PauliOperator"><code>PauliOperator</code></a>, <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L361-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.Stabilizer-Tuple{Graphs.SimpleGraphs.SimpleGraph}" href="#QuantumClifford.Stabilizer-Tuple{Graphs.SimpleGraphs.SimpleGraph}"><code>QuantumClifford.Stabilizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a graph representing a stabilizer state to an explicit Stabilizer.</p><p>See also: <a href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>graphstate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/graphs.jl#L92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sCNOT" href="#QuantumClifford.sCNOT"><code>QuantumClifford.sCNOT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; CNOT. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sCPHASE" href="#QuantumClifford.sCPHASE"><code>QuantumClifford.sCPHASE</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; CPHASE. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sHadamard" href="#QuantumClifford.sHadamard"><code>QuantumClifford.sHadamard</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; single-qubit Hadamard. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sId1" href="#QuantumClifford.sId1"><code>QuantumClifford.sId1</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; single-qubit Identity operation.</p><p>See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sInvPhase" href="#QuantumClifford.sInvPhase"><code>QuantumClifford.sInvPhase</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; single-qubit InvPhase. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sMX" href="#QuantumClifford.sMX"><code>QuantumClifford.sMX</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Symbolic single qubit X measurement. See also <a href="#QuantumClifford.Register"><code>Register</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumClifford.sMY"><code>sMY</code></a>, <a href="#QuantumClifford.sMZ"><code>sMZ</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sMY" href="#QuantumClifford.sMY"><code>QuantumClifford.sMY</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Symbolic single qubit Y measurement. See also <a href="#QuantumClifford.Register"><code>Register</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a>, <a href="#QuantumClifford.sMX"><code>sMX</code></a>, <a href="#QuantumClifford.sMZ"><code>sMZ</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sMZ" href="#QuantumClifford.sMZ"><code>QuantumClifford.sMZ</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Symbolic single qubit Z measurement. See also <a href="#QuantumClifford.Register"><code>Register</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a>, <a href="#QuantumClifford.sMX"><code>sMX</code></a>, <a href="#QuantumClifford.sMY"><code>sMY</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sPhase" href="#QuantumClifford.sPhase"><code>QuantumClifford.sPhase</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; single-qubit Phase. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sSWAP" href="#QuantumClifford.sSWAP"><code>QuantumClifford.sSWAP</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; SWAP. See also: <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sX" href="#QuantumClifford.sX"><code>QuantumClifford.sX</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; single-qubit X. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sY" href="#QuantumClifford.sY"><code>QuantumClifford.sY</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; single-qubit Y. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.sZ" href="#QuantumClifford.sZ"><code>QuantumClifford.sZ</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A &quot;symbolic&quot; single-qubit Z. See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.AbstractSymbolicOperator"><code>AbstractSymbolicOperator</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.bell" href="#QuantumClifford.bell"><code>QuantumClifford.bell</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Prepare one or more Bell pairs (with optional phases).</p><pre><code class="language-julia-repl hljs">julia&gt; bell()
+ XX
+ ZZ

julia&gt; bell(2)
+ XX__
+ ZZ__
+ __XX
+ __ZZ

julia&gt; bell((true, false))
- XX
+ ZZ

julia&gt; bell([true, false, true, true])
- XX__
+ ZZ__
- __XX
- __ZZ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/useful_states.jl#L52-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.bigram-Tuple{QuantumClifford.AbstractStabilizer}" href="#QuantumClifford.bigram-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.bigram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bigram(
    state::QuantumClifford.AbstractStabilizer;
    clip
) -&gt; Matrix{Int64}
</code></pre><p>Get the bigram of a tableau.</p><p>It is the list of endpoints of a tableau in the clipped gauge.</p><p>If <code>clip=true</code> (the default) the tableau is converted to the clipped gauge in-place before calculating the bigram. Otherwise, the clip gauge conversion is skipped (for cases where the input is already known to be in the correct gauge).</p><p>Introduced in <a href="../references/#nahum2017quantum">Adam Nahum, Jonathan Ruhman, Sagar Vijay, Jeongwan Haah (2017)</a>, with a more detailed explanation of the algorithm in Appendix A of <a href="../references/#li2019measurement">Yaodong Li, Xiao Chen, Matthew PA Fisher (2019)</a></p><p>See also: <a href="#QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize_clip!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/entanglement.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.bitview" href="#QuantumClifford.bitview"><code>QuantumClifford.bitview</code></a> — <span class="docstring-category">Function</span></header><section><div><p>A view of the classical bits stored with the state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/classical_register.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}" href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.canonicalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonicalize!(
    state::QuantumClifford.AbstractStabilizer;
    phases,
    ranks
) -&gt; Any
</code></pre><p>Canonicalize a stabilizer (in place).</p><p>Assumes the input is a valid stabilizer (all operators commute and have real phases). It permits redundant generators and identity generators.</p><pre><code class="language-julia-repl hljs">julia&gt; ghz = S&quot;XXXX
               ZZII
               IZZI
               IIZZ&quot;;

julia&gt; canonicalize!(ghz)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ

julia&gt; canonicalize!(S&quot;XXXX
                       IZZI
                       IIZZ&quot;)
+ XXXX
+ _Z_Z
+ __ZZ</code></pre><p>Not all rows in the tableau in the next example are independent:</p><pre><code class="language-julia-repl hljs">julia&gt; canonicalize!(S&quot;XXXX
                       ZZII
                       IZZI
                       IZIZ
                       IIZZ&quot;)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ
+ ____</code></pre><p>In cases of lower rank, more advanced tableau structures might be better. For instance the <a href="#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a> or <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> structures (you can read more about them in the <a href="../datastructures/#Choosing-Appropriate-Data-Structure">Data Structures section</a> of the documentation).</p><p>If <code>phases=false</code> is set, the canonicalization does not track the phases in the tableau, leading to significant (constant factor) speedup.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;-ZX
              XZ&quot;
- ZX
+ XZ

julia&gt; canonicalize!(copy(s), phases=false)
- XZ
+ ZX

julia&gt; canonicalize!(copy(s))
+ XZ
- ZX</code></pre><p>If <code>ranks=true</code> is set, the last pivot indices for the X and Z stage of the canonicalization are returned as well.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;XXXX
             ZZII
             IZIZ
             ZIIZ&quot;;

julia&gt; canonicalize!(s, ranks=true)
(+ XXXX
+ Z__Z
+ _Z_Z
+ ____, 1, 3)</code></pre><p>Based on <a href="../references/#garcia2012efficient">Hector J Garcia, Igor L Markov, Andrew W Cross (2012)</a>.</p><p>See also: <a href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>canonicalize_rref!</code></a>, <a href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/canonicalization.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}" href="#QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.canonicalize_clip!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonicalize_clip!(
    state::QuantumClifford.AbstractStabilizer;
    phases
) -&gt; QuantumClifford.AbstractStabilizer
</code></pre><p>Fix the clipped gauge of a stabilizer (in place).</p><p>Assumes the input is a valid full-rank stabilizer (all operators commute and have real phases).</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;- X_ZX_X
             + XXYZ__
             - YZ_Z_X
             - XZX__Y
             + _Z_Y_Y
             - ____Z_&quot;;

julia&gt; canonicalize_clip!(s)
- X_XY__
+ YZY___
+ _XZX__
- _ZYX_Z
- __YZ_X
- ____Z_</code></pre><p>If <code>phases=false</code> is set, the canonicalization does not track the phases in the tableau, leading to a significant speedup.</p><p>Introduced in <a href="../references/#nahum2017quantum">Adam Nahum, Jonathan Ruhman, Sagar Vijay, Jeongwan Haah (2017)</a>, with a more detailed explanation of the algorithm in Appendix A of <a href="../references/#li2019measurement">Yaodong Li, Xiao Chen, Matthew PA Fisher (2019)</a></p><p>See also: <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>, <a href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>canonicalize_rref!</code></a>, <a href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/entanglement.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}" href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>QuantumClifford.canonicalize_gott!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Inplace Gottesman canonicalization of a tableau.</p><p>This uses different canonical form from <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>. It is used in the computation of the logical X and Z operators of a <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a>.</p><p>It returns the (in place) modified state, the indices of the last pivot of both Gaussian elimination steps, and the permutations that have been used to put the X and Z tableaux in standard form.</p><p>Based on <a href="../references/#gottesman1997stabilizer">Daniel Gottesman (1997)</a>.</p><p>See also: <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>, <a href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>canonicalize_rref!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/canonicalization.jl#L201-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}" href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>QuantumClifford.canonicalize_rref!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonicalize_rref!(
    state::QuantumClifford.AbstractStabilizer,
    colindices;
    phases
) -&gt; Tuple{QuantumClifford.AbstractStabilizer, Any}
</code></pre><p>Canonicalize a stabilizer (in place) along only some columns.</p><p>This uses different canonical form from <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>. It also indexes in reverse in order to make its use in <a href="#QuantumInterface.traceout!-Tuple{Stabilizer, Any}"><code>traceout!</code></a> more efficient. Its use in <code>traceout!</code> is its main application.</p><p>It returns the (in place) modified state and the index of the last pivot.</p><p>Based on <a href="../references/#audenaert2005entanglement">Koenraad MR Audenaert, Martin B Plenio (2005)</a>.</p><p>See also: <a href="#QuantumClifford.canonicalize!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize!</code></a>, <a href="#QuantumClifford.canonicalize_gott!-Tuple{Stabilizer}"><code>canonicalize_gott!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/canonicalization.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer}" href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.canonicalize_rref!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonicalize_rref!(
    state::QuantumClifford.AbstractStabilizer;
    phases
) -&gt; Tuple{QuantumClifford.AbstractStabilizer, Any}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/canonicalization.jl#L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.clifford_cardinality-Tuple{Int64}" href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>QuantumClifford.clifford_cardinality</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The size of the Clifford group over a given number of qubits, possibly modulo the phases.</p><p>For n qubits, not accounting for phases is 2ⁿⁿΠⱼ₌₁ⁿ(4ʲ-1). There are 4ⁿ different phase configurations.</p><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/enumeration.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.comm-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned" href="#QuantumClifford.comm-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned"><code>QuantumClifford.comm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check whether two operators commute.</p><p><code>0x0</code> if they commute, <code>0x1</code> if they anticommute.</p><pre><code class="language-julia-repl hljs">julia&gt; P&quot;XX&quot;*P&quot;ZZ&quot;, P&quot;ZZ&quot;*P&quot;XX&quot;
(- YY, - YY)

julia&gt; comm(P&quot;ZZ&quot;, P&quot;XX&quot;)
0x00

julia&gt; comm(P&quot;IZ&quot;, P&quot;XX&quot;)
0x01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L808-L823">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.destabilizerview-Tuple{Destabilizer}" href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>QuantumClifford.destabilizerview</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A view of the subtableau corresponding to the destabilizer. See also <a href="#QuantumClifford.tab-Union{Tuple{Stabilizer{T}}, Tuple{T}} where T"><code>tab</code></a>, <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.enumerate_cliffords-Tuple{Any, Any}" href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>QuantumClifford.enumerate_cliffords</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Give the i-th n-qubit Clifford operation, where i∈{1..2ⁿⁿΠⱼ₌₁ⁿ(4ʲ-1)}</p><p>The algorithm is detailed in <a href="../references/#koenig2014efficiently">Robert Koenig, John A Smolin (2014)</a>.</p><p>See also: <a href="#QuantumClifford.symplecticGS-Tuple{PauliOperator}"><code>symplecticGS</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/enumeration.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.enumerate_cliffords-Tuple{Any}" href="#QuantumClifford.enumerate_cliffords-Tuple{Any}"><code>QuantumClifford.enumerate_cliffords</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Give all n-qubit Clifford operations.</p><p>The algorithm is detailed in <a href="../references/#koenig2014efficiently">Robert Koenig, John A Smolin (2014)</a>.</p><p>See also: <a href="#QuantumClifford.symplecticGS-Tuple{PauliOperator}"><code>symplecticGS</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/enumeration.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.enumerate_phases-Tuple{CliffordOperator}" href="#QuantumClifford.enumerate_phases-Tuple{CliffordOperator}"><code>QuantumClifford.enumerate_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given an operator, return all operators that have the same tableau but different phases.</p><pre><code class="language-julia-repl hljs">julia&gt; length(collect(enumerate_phases(tCNOT)))
16</code></pre><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/enumeration.jl#L176-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.enumerate_phases-Tuple{Union{Base.Generator, AbstractVector}}" href="#QuantumClifford.enumerate_phases-Tuple{Union{Base.Generator, AbstractVector}}"><code>QuantumClifford.enumerate_phases</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a set of operators, return all operators that have the same tableaux but different phases.</p><pre><code class="language-julia-repl hljs">julia&gt; length(collect(enumerate_phases(enumerate_cliffords(2))))
11520</code></pre><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/enumeration.jl#L189-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.enumerate_single_qubit_gates-Tuple{Any}" href="#QuantumClifford.enumerate_single_qubit_gates-Tuple{Any}"><code>QuantumClifford.enumerate_single_qubit_gates</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate a symbolic single-qubit gate given its index. Optionally, set non-trivial phases.</p><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/enumeration.jl#L10-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.generate!-Tuple{PauliOperator, Stabilizer}" href="#QuantumClifford.generate!-Tuple{PauliOperator, Stabilizer}"><code>QuantumClifford.generate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate a Pauli operator by using operators from a given the Stabilizer.</p><p><strong>It assumes the stabilizer is already canonicalized.</strong> It modifies the Pauli operator in place, generating it in reverse, up to a phase. That phase is left in the modified operator, which should be the identity up to a phase. Returns the new operator and the list of indices denoting the elements of <code>stabilizer</code> that were used for the generation.</p><pre><code class="language-julia-repl hljs">julia&gt; ghz = S&quot;XXXX
               ZZII
               IZZI
               IIZZ&quot;;

julia&gt; canonicalize!(ghz)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ

julia&gt; generate!(P&quot;-ZIZI&quot;, ghz)
(- ____, [2, 4])</code></pre><p>When the Pauli operator can not be generated by the given tableau, <code>nothing</code> is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; generate!(P&quot;XII&quot;,canonicalize!(S&quot;ZII&quot;)) === nothing
true

julia&gt; generate!(P&quot;XII&quot;,canonicalize!(S&quot;XII&quot;)) === nothing
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.gf2_H_to_G-Tuple{Any}" href="#QuantumClifford.gf2_H_to_G-Tuple{Any}"><code>QuantumClifford.gf2_H_to_G</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For a given F(2,2) parity check matrix, return the generator matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L1243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.gf2_gausselim!-Tuple{Any}" href="#QuantumClifford.gf2_gausselim!-Tuple{Any}"><code>QuantumClifford.gf2_gausselim!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gaussian elimination over the binary field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L1188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.gf2_invert-Tuple{Any}" href="#QuantumClifford.gf2_invert-Tuple{Any}"><code>QuantumClifford.gf2_invert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Invert a binary matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L1218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.gf2_isinvertible-Tuple{Any}" href="#QuantumClifford.gf2_isinvertible-Tuple{Any}"><code>QuantumClifford.gf2_isinvertible</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check whether a binary matrix is invertible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L1212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.ghz" href="#QuantumClifford.ghz"><code>QuantumClifford.ghz</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Prepare a GHZ state of n qubits.</p><pre><code class="language-julia-repl hljs">julia&gt; ghz()
+ XXX
+ ZZ_
+ _ZZ

julia&gt; ghz(2)
+ XX
+ ZZ

julia&gt; ghz(4)
+ XXXX
+ ZZ__
+ _ZZ_
+ __ZZ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/useful_states.jl#L106-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.graph_gate-NTuple{4, Any}" href="#QuantumClifford.graph_gate-NTuple{4, Any}"><code>QuantumClifford.graph_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A helper function converting the gate indices from <a href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>graphstate</code></a> into a Clifford operator.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot; XXX
              YZ_
             -_ZZ&quot;;

julia&gt; graph, h_idx, ip_idx, z_idx = graphstate(s);

julia&gt; gate = graph_gate(h_idx, ip_idx, z_idx, nqubits(s));

julia&gt; apply!(s, gate) # This is now a graph state (notice you need to multiply row 1 by row 2)
+ YYZ
+ XZ_
+ _ZX

julia&gt; canonicalize!(s) == canonicalize!(Stabilizer(graph))
true</code></pre><p>See also: <a href="#QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>graph_gatesequence</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/graphs.jl#L134-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}" href="#QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>QuantumClifford.graph_gatesequence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A helper function converting the gate indices from <a href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>graphstate</code></a> into a sequence of gates.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot; XXX
              YZ_
             -_ZZ&quot;;

julia&gt; graph, h_idx, ip_idx, z_idx = graphstate(s);

julia&gt; gates = graph_gatesequence(h_idx, ip_idx, z_idx);

julia&gt; for gate in vcat(gates...) apply!(s, gate) end

julia&gt; s # This is now a graph state (notice you need to multiply row 1 by row 2)
+ YYZ
+ XZ_
+ _ZX

julia&gt; canonicalize!(s) == canonicalize!(Stabilizer(graph))
true</code></pre><p>See also: <a href="#QuantumClifford.graph_gatesequence-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>graph_gatesequence</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/graphs.jl#L106-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.graphstate!-Tuple{Stabilizer}" href="#QuantumClifford.graphstate!-Tuple{Stabilizer}"><code>QuantumClifford.graphstate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An in-place version of <a href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>graphstate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/graphs.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}" href="#QuantumClifford.graphstate-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.graphstate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert any stabilizer state to a graph state</p><p><a href="https://en.wikipedia.org/wiki/Graph_state">Graph states</a> are a special type of entangled stabilizer states that can be represented by a graph. For a graph <span>$G=(V,E)$</span> the corresponding stabilizers are <span>$S_v = X_v \prod_{u ∈ N(v)} Z_u$</span>. Notice that such tableau rows contain only a single X operator. There is a set of single qubit gates that converts any stabilizer state to a graph state.</p><p>This function returns the graph state corresponding to a stabilizer and the gates that might be necessary to convert the stabilizer into a state representable as a graph.</p><p>For a tableau <code>stab</code> you can convert it with:</p><pre><code class="language-julia hljs">graph, hadamard_idx, iphase_idx, flips_idx = graphstate()</code></pre><p>where <code>graph</code> is the graph representation of <code>stab</code>, and the rest specifies the single-qubit gates converting <code>stab</code> to <code>graph</code>: <code>hadamard_idx</code> are the qubits that require a Hadamard gate (mapping X ↔ Z), <code>iphase_idx</code> are (different) qubits that require an inverse Phase gate (Y → X), and <code>flips_idx</code> are the qubits that require a phase flip (Pauli Z gate), after the previous two sets of gates.</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs

julia&gt; s = S&quot; XXX
              ZZ_
             -_ZZ&quot;;

julia&gt; g, h_idx, ip_idx, z_idx = graphstate(s);

julia&gt; collect(edges(g))
2-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3

julia&gt; h_idx
2-element Vector{Int64}:
 2
 3

julia&gt; ip_idx
Int64[]

julia&gt; z_idx
1-element Vector{Int64}:
 3</code></pre><p>The <code>Graphs.jl</code> library provides many graph-theory tools and the <code>MakieGraphs.jl</code> library provides plotting utilies for graphs.</p><p>You can directly call the graph constructor on a stabilizer, if you just want the graph and do not care about the Clifford operation necessary to convert an arbitrary state to a state representable as a graph:</p><pre><code class="language-julia-repl hljs">julia&gt; collect(edges( Graph(bell()) ))
1-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:
 Edge 1 =&gt; 2</code></pre><p>For a version that does not copy the stabilizer, but rather performs transformations in-place, use <code>graphstate!</code>. It would perform <code>canonicalize_gott!</code> on its argument as it finds a way to convert it to a graph state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/graphs.jl#L20-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.logdot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}" href="#QuantumClifford.logdot-Tuple{QuantumClifford.AbstractStabilizer, QuantumClifford.AbstractStabilizer}"><code>QuantumClifford.logdot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Logarithm of the inner product between to Stabilizer states.</p><p>If the result is <code>nothing</code>, the dot inner product is zero. Otherwise the inner product is <code>2^(-logdot/2)</code>.</p><p>The actual inner product can be computed with <code>LinearAlgebra.dot</code>.</p><p>Based on <a href="../references/#garcia2012efficient">Hector J Garcia, Igor L Markov, Andrew W Cross (2012)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/linalg.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.logicalxview-Tuple{MixedDestabilizer}" href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>QuantumClifford.logicalxview</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A view of the subtableau corresponding to the logical X operators. See also <a href="#QuantumClifford.tab-Union{Tuple{Stabilizer{T}}, Tuple{T}} where T"><code>tab</code></a>, <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.logicalzview-Tuple{MixedDestabilizer}" href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>QuantumClifford.logicalzview</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A view of the subtableau corresponding to the logical Z operators. See also <a href="#QuantumClifford.tab-Union{Tuple{Stabilizer{T}}, Tuple{T}} where T"><code>tab</code></a>, <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.phases-Tuple{QuantumClifford.Tableau}" href="#QuantumClifford.phases-Tuple{QuantumClifford.Tableau}"><code>QuantumClifford.phases</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The phases of a given tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L734">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned" href="#QuantumClifford.prodphase-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Unsigned"><code>QuantumClifford.prodphase</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the phase of the product of two Pauli operators.</p><p>Phase is encoded as F(4) in the low qubits of an UInt8.</p><pre><code class="language-julia-repl hljs">julia&gt; P&quot;ZZZ&quot;*P&quot;XXX&quot;
-iYYY

julia&gt; prodphase(P&quot;ZZZ&quot;, P&quot;XXX&quot;)
0x03

julia&gt; prodphase(P&quot;XXX&quot;, P&quot;ZZZ&quot;)
0x01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L742-L757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.projectXrand!-Tuple{Any, Any}" href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>QuantumClifford.projectXrand!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectXrand!(state, qubit) -&gt; Tuple{Register, UInt8}
</code></pre><p>Project <code>qubit</code> of <code>state</code> along the X axis and randomize the phase if necessary.</p><p>Lower boilerplate version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.projectYrand!-Tuple{Any, Any}" href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>QuantumClifford.projectYrand!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectYrand!(state, qubit) -&gt; Tuple{Register, UInt8}
</code></pre><p>Project <code>qubit</code> of <code>state</code> along the Y axis and randomize the phase if necessary.</p><p>Lower boilerplate version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.projectZrand!-Tuple{Any, Any}" href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>QuantumClifford.projectZrand!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectZrand!(state, qubit) -&gt; Tuple{Register, UInt8}
</code></pre><p>Project <code>qubit</code> of <code>state</code> along the Z axis and randomize the phase if necessary.</p><p>Lower boilerplate version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.projectrand!-Tuple{Any, Any}" href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>QuantumClifford.projectrand!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectrand!(
    state,
    pauli
) -&gt; Tuple{QuantumClifford.AbstractStabilizer, UInt8}
</code></pre><p>Measure <code>pauli</code> operator on <code>state</code> and randomize the phase if necessary.</p><p>Lower boilerplate version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.puttableau!-Union{Tuple{M2}, Tuple{M1}, Tuple{T}, Tuple{V2}, Tuple{V1}, Tuple{B}, Tuple{QuantumClifford.Tableau{V1, M1}, QuantumClifford.Tableau{V2, M2}, Int64, Int64}} where {B, V1, V2, T&lt;:Unsigned, M1&lt;:AbstractMatrix{T}, M2&lt;:AbstractMatrix{T}}" href="#QuantumClifford.puttableau!-Union{Tuple{M2}, Tuple{M1}, Tuple{T}, Tuple{V2}, Tuple{V1}, Tuple{B}, Tuple{QuantumClifford.Tableau{V1, M1}, QuantumClifford.Tableau{V2, M2}, Int64, Int64}} where {B, V1, V2, T&lt;:Unsigned, M1&lt;:AbstractMatrix{T}, M2&lt;:AbstractMatrix{T}}"><code>QuantumClifford.puttableau!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Put source tableau in target tableau at given row and column. Assumes target location is zeroed out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.quantumstate" href="#QuantumClifford.quantumstate"><code>QuantumClifford.quantumstate</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Only the quantum part of the state (excluding classical bits)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/classical_register.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.random_clifford-Tuple{Random.AbstractRNG, Int64}" href="#QuantumClifford.random_clifford-Tuple{Random.AbstractRNG, Int64}"><code>QuantumClifford.random_clifford</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A random Clifford operator generated by the Bravyi-Maslov Algorithm 2 from <a href="../references/#bravyi2020hadamard">Sergey Bravyi, Dmitri Maslov (2021)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/randoms.jl#L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.random_clifford1-Tuple{Random.AbstractRNG, Any}" href="#QuantumClifford.random_clifford1-Tuple{Random.AbstractRNG, Any}"><code>QuantumClifford.random_clifford1</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Random symbolic single-qubit Clifford applied to qubit at index <code>qubit</code>.</p><p>See also: <a href="#QuantumClifford.SingleQubitOperator"><code>SingleQubitOperator</code></a>, <a href="#QuantumClifford.random_clifford-Tuple{Random.AbstractRNG, Int64}"><code>random_clifford</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/symbolic_cliffords.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.random_destabilizer-Tuple{Random.AbstractRNG, Int64}" href="#QuantumClifford.random_destabilizer-Tuple{Random.AbstractRNG, Int64}"><code>QuantumClifford.random_destabilizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A random Stabilizer/Destabilizer tableau generated by the Bravyi-Maslov Algorithm 2 from <a href="../references/#bravyi2020hadamard">Sergey Bravyi, Dmitri Maslov (2021)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/randoms.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.random_pauli-Tuple{Random.AbstractRNG, Int64}" href="#QuantumClifford.random_pauli-Tuple{Random.AbstractRNG, Int64}"><code>QuantumClifford.random_pauli</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A random Pauli operator on n qubits.</p><p>Use <code>realphase=true</code> to get operators with phase ±1 (excluding ±i). <code>nophase=true</code> sets the phase to +1.</p><p>Optionally, a &quot;flip&quot; probability <code>p</code> can be provided specified, in which case each bit is set to I with probability <code>1-p</code> and to X, Y, or Z, each with probability <code>p</code>. Useful for simulating Pauli noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/randoms.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.random_stabilizer-Tuple{Random.AbstractRNG, Int64}" href="#QuantumClifford.random_stabilizer-Tuple{Random.AbstractRNG, Int64}"><code>QuantumClifford.random_stabilizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A random Stabilizer tableau generated by the Bravyi-Maslov Algorithm 2 from <a href="../references/#bravyi2020hadamard">Sergey Bravyi, Dmitri Maslov (2021)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/randoms.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.single_x-Tuple{Any, Any}" href="#QuantumClifford.single_x-Tuple{Any, Any}"><code>QuantumClifford.single_x</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A multiqubit operator corresponding to all identities except for Pauli X at <code>i</code>. See also: <a href="#QuantumClifford.sX"><code>sX</code></a>, <a href="#QuantumClifford.sMX"><code>sMX</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/useful_states.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.single_y-Tuple{Any, Any}" href="#QuantumClifford.single_y-Tuple{Any, Any}"><code>QuantumClifford.single_y</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A multiqubit operator corresponding to all identities except for Pauli Y at <code>i</code>. See also: <a href="#QuantumClifford.sY"><code>sY</code></a>, <a href="#QuantumClifford.sMY"><code>sMY</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/useful_states.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.single_z-Tuple{Any, Any}" href="#QuantumClifford.single_z-Tuple{Any, Any}"><code>QuantumClifford.single_z</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A multiqubit operator corresponding to all identities except for Pauli Z at <code>i</code>. See also: <a href="#QuantumClifford.sY"><code>sY</code></a>, <a href="#QuantumClifford.sMY"><code>sMY</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/useful_states.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.stab_to_gf2-Tuple{QuantumClifford.Tableau}" href="#QuantumClifford.stab_to_gf2-Tuple{QuantumClifford.Tableau}"><code>QuantumClifford.stab_to_gf2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The F(2,2) matrix of a given tableau, represented as the concatenation of two binary matrices, one for X and one for Z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L1175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.stabilizerview-Tuple{Stabilizer}" href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>QuantumClifford.stabilizerview</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A view of the subtableau corresponding to the stabilizer. See also <a href="#QuantumClifford.tab-Union{Tuple{Stabilizer{T}}, Tuple{T}} where T"><code>tab</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.symplecticGS-Tuple{PauliOperator}" href="#QuantumClifford.symplecticGS-Tuple{PauliOperator}"><code>QuantumClifford.symplecticGS</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform the Symplectic Gram-Schmidt procedure that gives a Clifford operator canonically related to a given Pauli operator.</p><p>The algorithm is detailed in <a href="../references/#koenig2014efficiently">Robert Koenig, John A Smolin (2014)</a>.</p><p>See also: <a href="#QuantumClifford.enumerate_cliffords-Tuple{Any, Any}"><code>enumerate_cliffords</code></a>, <a href="#QuantumClifford.clifford_cardinality-Tuple{Int64}"><code>clifford_cardinality</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/enumeration.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.tab-Union{Tuple{Stabilizer{T}}, Tuple{T}} where T" href="#QuantumClifford.tab-Union{Tuple{Stabilizer{T}}, Tuple{T}} where T"><code>QuantumClifford.tab</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract the underlying tableau structure.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;X&quot;
+ X

julia&gt; tab(s)
+ X

julia&gt; tab(Destabilizer(s))
+ Z
+ X

julia&gt; tab(MixedDestabilizer(s))
+ Z
+ X

julia&gt; tab(tHadamard)
+ Z
+ X

julia&gt; typeof(tab(tHadamard))
QuantumClifford.Tableau{Vector{UInt8}, Matrix{UInt64}}</code></pre><p>See also: <a href="#QuantumClifford.stabilizerview-Tuple{Stabilizer}"><code>stabilizerview</code></a>, <a href="#QuantumClifford.destabilizerview-Tuple{Destabilizer}"><code>destabilizerview</code></a>, <a href="#QuantumClifford.logicalxview-Tuple{MixedDestabilizer}"><code>logicalxview</code></a>, <a href="#QuantumClifford.logicalzview-Tuple{MixedDestabilizer}"><code>logicalzview</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L508-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.xbit-Tuple{PauliOperator}" href="#QuantumClifford.xbit-Tuple{PauliOperator}"><code>QuantumClifford.xbit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract as a new bit array the X part of the <code>UInt</code> array of packed qubits of a given Pauli operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.xview-Tuple{PauliOperator}" href="#QuantumClifford.xview-Tuple{PauliOperator}"><code>QuantumClifford.xview</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get a view of the X part of the <code>UInt</code> array of packed qubits of a given Pauli operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.zbit-Tuple{PauliOperator}" href="#QuantumClifford.zbit-Tuple{PauliOperator}"><code>QuantumClifford.zbit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract as a new bit array the Z part of the <code>UInt</code> array of packed qubits of a given Pauli operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumClifford.zview-Tuple{PauliOperator}" href="#QuantumClifford.zview-Tuple{PauliOperator}"><code>QuantumClifford.zview</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get a view of the Y part of the <code>UInt</code> array of packed qubits of a given Pauli operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.:⊗-Tuple{Vararg{QuantumClifford.AbstractStabilizer}}" href="#QuantumInterface.:⊗-Tuple{Vararg{QuantumClifford.AbstractStabilizer}}"><code>QuantumInterface.:⊗</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tensor product between operators or tableaux. See also <a href="@ref"><code>tensor</code></a> and <a href="#QuantumInterface.tensor_pow-Tuple{Any, Any}"><code>tensor_pow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/linalg.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.entanglement_entropy" href="#QuantumInterface.entanglement_entropy"><code>QuantumInterface.entanglement_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get bipartite entanglement entropy of a subsystem</p><p>Defined as entropy of the reduced density matrix.</p><p>It can be calculated with multiple different algorithms, the most performant one depending on the particular case.</p><p>Currently implemented are the <code>:clip</code>, <code>:graph</code>, and <code>:rref</code> algorithms. Benchmark your particular case to choose the best one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/entanglement.jl#L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:graph}}" href="#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:graph}}"><code>QuantumInterface.entanglement_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get bipartite entanglement entropy by first converting the state to a graph and computing the rank of the adjacency matrix.</p><p>Based on <a href="../references/#hein2006entanglement">M. Hein, W. Dür, J. Eisert, R. Raussendorf, M. Van den Nest, H.-J. Briegel (2006)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/entanglement.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:rref}}" href="#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, AbstractVector, Val{:rref}}"><code>QuantumInterface.entanglement_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get bipartite entanglement entropy by converting to RREF form (i.e., partial trace form).</p><p>The state will be partially canonicalized in an RREF form.</p><p>See also: <a href="#QuantumClifford.canonicalize_rref!-Tuple{QuantumClifford.AbstractStabilizer, Any}"><code>canonicalize_rref!</code></a>, <a href="#QuantumInterface.traceout!-Tuple{Stabilizer, Any}"><code>traceout!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/entanglement.jl#L205-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, UnitRange, Val{:clip}}" href="#QuantumInterface.entanglement_entropy-Tuple{QuantumClifford.AbstractStabilizer, UnitRange, Val{:clip}}"><code>QuantumInterface.entanglement_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get bipartite entanglement entropy of a contiguous subsystem by passing through the clipped gauge.</p><p>If <code>clip=false</code> is set the canonicalization step is skipped, useful if the input state is already in the clipped gauge.</p><p>See also: <a href="#QuantumClifford.bigram-Tuple{QuantumClifford.AbstractStabilizer}"><code>bigram</code></a>, <a href="#QuantumClifford.canonicalize_clip!-Tuple{QuantumClifford.AbstractStabilizer}"><code>canonicalize_clip!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/entanglement.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.expect-Tuple{PauliOperator, QuantumClifford.AbstractStabilizer}" href="#QuantumInterface.expect-Tuple{PauliOperator, QuantumClifford.AbstractStabilizer}"><code>QuantumInterface.expect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expect(p::PauliOperator, st::AbstractStabilizer)</code></pre><p>Compute the expectation value of a Pauli operator <code>p</code> on a stabilizer state <code>st</code>. This function will allocate a temporary copy of the stabilizer state <code>st</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L726-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.nqubits-Tuple{QuantumClifford.AbstractStabilizer}" href="#QuantumInterface.nqubits-Tuple{QuantumClifford.AbstractStabilizer}"><code>QuantumInterface.nqubits</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The number of qubits of a given state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/QuantumClifford.jl#L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.project!-Tuple{Any, PauliOperator}" href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>QuantumInterface.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(
    state,
    pauli::PauliOperator;
    keep_result,
    phases
) -&gt; Tuple{MixedStabilizer, Any, Any}
</code></pre><p>Project the state of a Stabilizer on the two eigenspaces of a Pauli operator.</p><p>Assumes the input is a valid stabilizer. The projection is done inplace on that stabilizer and it does not modify the projection operator.</p><p>It returns</p><ul><li>a stabilizer that might not be in canonical form</li><li>the index of the row where the non-commuting operator was (that row is now equal to <code>pauli</code>; its phase is not updated and for a faithful measurement simulation it needs to be randomized by the user)</li><li>and the result of the projection if there was no non-commuting operator (<code>nothing</code> otherwise)</li></ul><p>If <code>keep_result==false</code> that result of the projection in case of anticommutation is not computed, sparing a canonicalization operation. This canonicalization operation is the only one potentially of cubic complexity. The rest of the calculations are of quadratic complexity.</p><p>If you need to measure a single qubit instead of a multiqubit Pauli operator, the faster <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, and <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a> are available.</p><p>For less boilerplate and automatic randomization of the phase use <a href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>projectrand!</code></a>.</p><p>Here is an example of a projection destroying entanglement:</p><pre><code class="language-julia-repl hljs">julia&gt; ghz = S&quot;XXXX
               ZZII
               IZZI
               IIZZ&quot;;

julia&gt; canonicalize!(ghz)
+ XXXX
+ Z__Z
+ _Z_Z
+ __ZZ

julia&gt; state, anticom_index, result = project!(ghz, P&quot;ZIII&quot;);

julia&gt; state
+ Z___
+ Z__Z
+ _Z_Z
+ __ZZ

julia&gt; canonicalize!(state)
+ Z___
+ _Z__
+ __Z_
+ ___Z

julia&gt; anticom_index, result
(1, nothing)</code></pre><p>And an example of projection consistent with the stabilizer state.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;ZII
             IXI
             IIY&quot;;

julia&gt; canonicalize!(s)
+ _X_
+ __Y
+ Z__

julia&gt; state, anticom_index, result = project!(s, P&quot;-ZII&quot;);

julia&gt; state
+ _X_
+ __Y
+ Z__

julia&gt; anticom_index, result
(0, 0x02)</code></pre><p>While not the best choice, <code>Stabilizer</code> can be used for mixed states, simply by providing an incomplete tableau. In that case it is possible to attempt to project on an operator that can not be generated by the provided stabilizer operators. In that case we have <code>anticom_index==rank</code> and <code>result===nothing</code>, where <code>rank</code> is the the new rank of the tableau, one more than the number of rows in the initial tableau. However, if <code>keep_result</code> was set to <code>false</code>, then <code>anticom_index</code> would stay at zero.</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;XZI
             IZI&quot;;

julia&gt; project!(s, P&quot;IIX&quot;)
(+ X__
+ _Z_, 3, nothing)</code></pre><p>If we had used <a href="#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a> we would have added the projector to the list of stabilizers.</p><pre><code class="language-julia-repl hljs">julia&gt; s = one(MixedStabilizer, 2, 3)
Rank 2 stabilizer
+ Z__
+ _Z_

julia&gt; project!(s, P&quot;IIX&quot;)
(Rank 3 stabilizer
+ Z__
+ _Z_
+ __X, 3, nothing)</code></pre><p>However, <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> would be an even better choice as it has <span>$\mathcal{O}(n^2)$</span> complexity instead of the <span>$\mathcal{O}(n^3)$</span> complexity of <code>*Stabilizer</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; s = one(MixedDestabilizer, 2, 3)
Rank 2 stabilizer
+ X__
+ _X_
━━━━━
+ __X
━━━━━
+ Z__
+ _Z_
━━━━━
+ __Z

julia&gt; project!(s, P&quot;IIX&quot;)
(Rank 3 stabilizer
+ X__
+ _X_
+ __Z
═════
+ Z__
+ _Z_
+ __X
═════
, 3, nothing)</code></pre><p>See the &quot;Datastructure Choice&quot; section in the documentation for more details.</p><p>See also: <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>, <a href="#QuantumClifford.projectrand!-Tuple{Any, Any}"><code>projectrand!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.project!-Tuple{MixedStabilizer, PauliOperator}" href="#QuantumInterface.project!-Tuple{MixedStabilizer, PauliOperator}"><code>QuantumInterface.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(
    state::MixedStabilizer,
    pauli::PauliOperator;
    phases
) -&gt; Tuple{MixedStabilizer, Any, Any}
</code></pre><p>When using <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a> on <a href="#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a> it automates some of the extra steps we encounter when implicitly using the <code>Stabilizer</code> datastructure to represent mixed states. Namely, it helps when the projector is not among the list of stabilizers:</p><pre><code class="language-julia-repl hljs">julia&gt; s = S&quot;XZI
             IZI&quot;;

julia&gt; ms = MixedStabilizer(s)
Rank 2 stabilizer
+ X__
+ _Z_

julia&gt; project!(ms, P&quot;IIY&quot;)
(Rank 3 stabilizer
+ X__
+ _Z_
+ __Y, 3, nothing)</code></pre><p>Similarly to <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a> on <a href="#QuantumClifford.Stabilizer"><code>Stabilizer</code></a>, this function has cubic complexity when the Pauli operator commutes with all rows of the tableau. Most of the time it is better to simply use <a href="#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> representation.</p><p>Unlike other <code>project!</code> methods, this one does not allow for <code>keep_result=false</code>, as the correct rank or anticommutation index can not be calculated without the expensive (cubic) canonicalization operation required by <code>keep_result=true</code>.</p><p>See the &quot;Datastructure Choice&quot; section in the documentation for more details.</p><p>See also: <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}" href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>QuantumInterface.projectX!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Measure a given qubit in the X basis. A faster special-case version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectXrand!-Tuple{Any, Any}"><code>projectXrand!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L443-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}" href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>QuantumInterface.projectY!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Measure a given qubit in the Y basis. A faster special-case version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectYrand!-Tuple{Any, Any}"><code>projectYrand!</code></a>, <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>, <a href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>projectZ!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L463-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}" href="#QuantumInterface.projectZ!-Tuple{MixedDestabilizer, Int64}"><code>QuantumInterface.projectZ!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Measure a given qubit in the Z basis. A faster special-case version of <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>.</p><p>See also: <a href="#QuantumInterface.project!-Tuple{Any, PauliOperator}"><code>project!</code></a>, <a href="#QuantumClifford.projectZrand!-Tuple{Any, Any}"><code>projectZrand!</code></a>, <a href="#QuantumInterface.projectY!-Tuple{MixedDestabilizer, Int64}"><code>projectY!</code></a>, <a href="#QuantumInterface.projectX!-Tuple{MixedDestabilizer, Int64}"><code>projectX!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L453-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.reset_qubits!-Tuple{MixedDestabilizer, QuantumClifford.AbstractStabilizer, Any}" href="#QuantumInterface.reset_qubits!-Tuple{MixedDestabilizer, QuantumClifford.AbstractStabilizer, Any}"><code>QuantumInterface.reset_qubits!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_qubits!(
    s::MixedDestabilizer,
    newstate::QuantumClifford.AbstractStabilizer,
    qubits;
    phases
) -&gt; MixedDestabilizer
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.reset_qubits!-Tuple{MixedStabilizer, Any, Any}" href="#QuantumInterface.reset_qubits!-Tuple{MixedStabilizer, Any, Any}"><code>QuantumInterface.reset_qubits!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_qubits!(
    s::MixedStabilizer,
    newstate,
    qubits;
    phases
) -&gt; MixedStabilizer
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.reset_qubits!-Tuple{Stabilizer, Any, Any}" href="#QuantumInterface.reset_qubits!-Tuple{Stabilizer, Any, Any}"><code>QuantumInterface.reset_qubits!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_qubits!(
    s::Stabilizer,
    newstate,
    qubits;
    phases
) -&gt; Any
</code></pre><p>Reset a given set of qubits to be in the state <code>newstate</code>. These qubits are traced out first, which could lead to &quot;nonlocal&quot; changes in the tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.tensor_pow-Tuple{Any, Any}" href="#QuantumInterface.tensor_pow-Tuple{Any, Any}"><code>QuantumInterface.tensor_pow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Repeated tensor product of an operators or a tableau. See also <a href="#QuantumInterface.:⊗-Tuple{Vararg{QuantumClifford.AbstractStabilizer}}"><code>⊗</code></a> and <a href="#QuantumInterface.tensor_pow-Tuple{Any, Any}"><code>tensor_pow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/linalg.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.traceout!-Tuple{Stabilizer, Any}" href="#QuantumInterface.traceout!-Tuple{Stabilizer, Any}"><code>QuantumInterface.traceout!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traceout!(s::Stabilizer, qubits; phases, rank) -&gt; Any
</code></pre><p>Trace out a qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.traceout!-Tuple{Union{MixedDestabilizer, MixedStabilizer}, Any}" href="#QuantumInterface.traceout!-Tuple{Union{MixedDestabilizer, MixedStabilizer}, Any}"><code>QuantumInterface.traceout!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traceout!(
    s::Union{MixedDestabilizer, MixedStabilizer},
    qubits;
    phases,
    rank
) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Krastanov/QuantumClifford.jl/blob/b99b0dbebe810835eb29fc4e2bfeb7e1865cffd5/src/project_trace_reset.jl#L638">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting/">« Plotting</a><a class="docs-footer-nextpage" href="../tutandpub/">Tutorials and Publications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 4 December 2022 15:04">Sunday 4 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
