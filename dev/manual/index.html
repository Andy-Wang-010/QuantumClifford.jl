<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · QuantumClifford.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuantumClifford.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumClifford.jl</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Pauli-Operators"><span>Pauli Operators</span></a></li><li class="toplevel"><a class="tocitem" href="#Stabilizers"><span>Stabilizers</span></a></li><li class="toplevel"><a class="tocitem" href="#Canonicalization-of-Stabilizers"><span>Canonicalization of Stabilizers</span></a></li><li class="toplevel"><a class="tocitem" href="#Projective-Measurements"><span>Projective Measurements</span></a></li><li class="toplevel"><a class="tocitem" href="#Partial-Traces"><span>Partial Traces</span></a></li><li class="toplevel"><a class="tocitem" href="#Generating-a-Pauli-Operator-with-Stabilizer-Generators"><span>Generating a Pauli Operator with Stabilizer Generators</span></a></li><li class="toplevel"><a class="tocitem" href="#Clifford-Operators"><span>Clifford Operators</span></a></li><li class="toplevel"><a class="tocitem" href="#Destabilizers"><span>Destabilizers</span></a></li><li class="toplevel"><a class="tocitem" href="#Mixed-States"><span>Mixed States</span></a></li></ul></li><li><a class="tocitem" href="../canonicalization/">Canonicalization</a></li><li><a class="tocitem" href="../mixed/">Mixed States</a></li><li><a class="tocitem" href="../datastructures/">Datastructure Choice</a></li><li><a class="tocitem" href="../commonstates/">Useful States and Operators</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../tutandpub/">Tutorials and Publications</a></li><li><span class="tocitem">NoisyCircuits</span><ul><li><a class="tocitem" href="../noisycircuits_mc/">Monte Carlo</a></li><li><a class="tocitem" href="../noisycircuits_perturb/">Leading-order Expansions</a></li><li><a class="tocitem" href="../noisycircuits_API/">API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Krastanov/QuantumClifford.jl/blob/master/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><h1 id="Pauli-Operators"><a class="docs-heading-anchor" href="#Pauli-Operators">Pauli Operators</a><a id="Pauli-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Pauli-Operators" title="Permalink"></a></h1><p>The <a href="../API/#QuantumClifford.PauliOperator"><code>PauliOperator</code></a> object representes multi-qubit Pauli operator (<span>$±\{1,i\}\{I,Z,X,Y\}^{\otimes n}$</span>). It is stored in memory as a phase (a single byte where <code>0x0,0x1,0x2,0x3</code> corresponds to <span>$1,i,-1,-i$</span>) and two bit-arrays, for X and for Z components.</p><p>You can create them with a <code>P</code> string.</p><pre><code class="language-julia-repl">julia&gt; P&quot;-iXZ&quot;
-iXZ</code></pre><p>Or by specifying phase and X/Z components:</p><pre><code class="language-julia-repl">julia&gt; PauliOperator(0x0,Bool[0,1,0],Bool[0,0,1])
+ _XZ</code></pre><p>Both underscore and I can be used for identity.</p><pre><code class="language-julia-repl">julia&gt; P&quot;I_XYZ&quot;
+ __XYZ</code></pre><p>Multiplication with scalars or other Pauli operators works as expected, as well as tensor products of Pauli operators.</p><pre><code class="language-julia-repl">julia&gt; -1im*P&quot;X&quot;
-iX

julia&gt; P&quot;X&quot; * P&quot;Z&quot;
-iY

julia&gt; P&quot;X&quot; ⊗ P&quot;Z&quot;
+ XZ</code></pre><p>One can check for commutativity with <a href="../API/#QuantumClifford.comm-Tuple{AbstractArray{UInt64,1},AbstractArray{UInt64,1}}"><code>comm</code></a>.</p><pre><code class="language-julia-repl">julia&gt; comm(P&quot;X&quot;,P&quot;Z&quot;)
0x01

julia&gt; comm(P&quot;XX&quot;,P&quot;ZZ&quot;)
0x00</code></pre><p>And check the phase of a product with <a href="../API/#QuantumClifford.prodphase-Tuple{AbstractArray{UInt64,1},AbstractArray{UInt64,1}}"><code>prodphase</code></a>.</p><pre><code class="language-julia-repl">julia&gt; prodphase(P&quot;X&quot;, P&quot;Z&quot;)
0x03

julia&gt; prodphase(P&quot;X&quot;, P&quot;iZ&quot;)
0x00

julia&gt; prodphase(P&quot;X&quot;,P&quot;Y&quot;)
0x01</code></pre><p>Indexing operations are available.</p><pre><code class="language-julia-repl">julia&gt; p = P&quot;IXYZ&quot;;

julia&gt; p[1], p[2], p[3], p[4]
((false, false), (true, false), (true, true), (false, true))

julia&gt; p = P&quot;III&quot;;

julia&gt; p[2] = (true, true);

julia&gt; p
+ _Y_</code></pre><p>Including fancy indexing:</p><pre><code class="language-julia-repl">julia&gt; P&quot;IXYZ&quot;[[2,3]]
+ XY

julia&gt; P&quot;IXYZ&quot;[[false,true,true,false]]
+ XY</code></pre><p>The operator is represented in memory by bit arrays (much denser than using byte arrays).</p><pre><code class="language-julia-repl">julia&gt; p = P&quot;-IXYZ&quot;;

julia&gt; p.nqubits, p.xz
(4, UInt64[0x0000000000000006, 0x000000000000000c])</code></pre><p>Views that give just the X or Z components of the <code>xz</code> bitarray are available through <a href="@ref"><code>xview</code></a> and <a href="@ref"><code>zview</code></a>.</p><pre><code class="language-julia-repl">julia&gt; xview(P&quot;XYZI&quot;)
1-element view(::Array{UInt64,1}, 1:1) with eltype UInt64:
 0x0000000000000003</code></pre><p>The convenience methods <a href="@ref"><code>xbit</code></a> and <a href="@ref"><code>zbit</code></a> give you Bool (GF2) vectors.</p><pre><code class="language-julia-repl">julia&gt; xbit(P&quot;XYZI&quot;)
4-element BitArray{1}:
 1
 1
 0
 0</code></pre><h1 id="Stabilizers"><a class="docs-heading-anchor" href="#Stabilizers">Stabilizers</a><a id="Stabilizers-1"></a><a class="docs-heading-anchor-permalink" href="#Stabilizers" title="Permalink"></a></h1><p>A <a href="../API/#QuantumClifford.Stabilizer"><code>Stabilizer</code></a> object is a tableau of Pauli operators. When the tableau is meant to represent a (pure or mixed) stabilizer state, all of these operators should commute (but that is not enforced, rather <code>Stabilizer</code> is a generic tableau data structure). It is stored in memory as a phase list and a bit-matrix for X and Z components. It can be instantiated by an <code>S</code> string, or with a number of different constructors.</p><p>For data structures that build upon this tableau representation to track other useful information, consider <a href="../API/#QuantumClifford.Destabilizer"><code>Destabilizer</code></a>, <a href="../API/#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a>, and <a href="../API/#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a>. See also the <a href="../datastructures/#Choosing-Appropriate-Data-Structure">data structures discussion page</a>.</p><pre><code class="language-julia-repl">julia&gt; S&quot;-XX
         +ZZ&quot;
- XX
+ ZZ

julia&gt; Stabilizer([P&quot;-XX&quot;,P&quot;+ZZ&quot;])
- XX
+ ZZ

julia&gt; Stabilizer([0x2, 0x0],
                  Bool[1 1;
                       0 0],
                  Bool[0 0;
                       1 1])
- XX
+ ZZ</code></pre><p>Direct sums can be performed,</p><pre><code class="language-julia-repl">julia&gt; S&quot;-XX&quot; ⊗ S&quot;ZZ&quot;
- XX__
+ __ZZ</code></pre><p>Indexing operations are available, including fancy indexing. Be careful about how phase information gets transferred during sub-indexing.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XYZ
             -ZIX
             +XIZ&quot;;

julia&gt; s[1]
- XYZ

julia&gt; s[1,2]
(true, true)

julia&gt; s[[3,1]]
+ X_Z
- XYZ

julia&gt; s[[3,1],[2]]
+ _
- Y</code></pre><p>Consistency at creation is not verified so nonsensical stabilizers can be created, both in terms of content and shape.</p><pre><code class="language-julia-repl">julia&gt; S&quot;iX
         +Z&quot;
+iX
+ Z</code></pre><p>Similarly to the Pauli operators, a bit array representation is used.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZI
             -IZZ&quot;
- XXX
+ ZZ_
- _ZZ

julia&gt; s.phases, s.nqubits, s.xzs
(UInt8[0x02, 0x00, 0x02], 3, UInt64[0x0000000000000007 0x0000000000000000; 0x0000000000000000 0x0000000000000003; 0x0000000000000000 0x0000000000000006])</code></pre><p>And there are convenience functions that can extract the corresponding binary check matrix.</p><pre><code class="language-julia-repl">julia&gt; stab_to_gf2(s)
3×6 BitArray{2}:
 1  1  1  0  0  0
 0  0  0  1  1  0
 0  0  0  0  1  1</code></pre><h1 id="Canonicalization-of-Stabilizers"><a class="docs-heading-anchor" href="#Canonicalization-of-Stabilizers">Canonicalization of Stabilizers</a><a id="Canonicalization-of-Stabilizers-1"></a><a class="docs-heading-anchor-permalink" href="#Canonicalization-of-Stabilizers" title="Permalink"></a></h1><p>Canonicalization (akin to Gaussian elimination over F(2,2)) is implemented in the <a href="../API/#QuantumClifford.canonicalize!-Tuple{Stabilizer}"><code>canonicalize!</code></a> function. Besides the default canonicalization prescription, alternative ones are available as described in the <a href="../canonicalization/#Canonicalization-operations">canonicalization page</a>.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZX
             +III&quot;;

julia&gt; canonicalize!(s)
+ YY_
+ ZZX
+ ___</code></pre><p>If phases are inconsequential, the operations can be faster by not tracking and updating them.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZX
             +III&quot;;

julia&gt; canonicalize!(s; phases=false)
- YY_
+ ZZX
+ ___</code></pre><p>These operations are in place (as customarily signified by &quot;!&quot;).</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZX
             +III&quot;;

julia&gt; canonicalize!(s; phases=false);

julia&gt; s
- YY_
+ ZZX
+ ___</code></pre><h1 id="Projective-Measurements"><a class="docs-heading-anchor" href="#Projective-Measurements">Projective Measurements</a><a id="Projective-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Projective-Measurements" title="Permalink"></a></h1><p>To observe the effect of different projections, we will start with a GHZ state.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZI
             -IZZ&quot;;</code></pre><p>The <a href="../API/#QuantumClifford.project!-Tuple{Stabilizer,PauliOperator}"><code>project!</code></a> function returns the new stabilizer, the index where the anticommutation was detected, and the result of the projection (<code>nothing</code> being an undetermined result). For instance here we project on an operator that does not commute with all stabilizer generators.</p><pre><code class="language-julia-repl">julia&gt; project!(copy(s), P&quot;ZII&quot;)
(+ Z__
+ ZZ_
- _ZZ, 1, nothing)</code></pre><p>Importantly, when there is an undetermined result, we return <code>nothing</code> <strong>and leave the phase of the new stabilizer the same as the phase of the projection operator</strong>. If you want to perform a Monte Carlo simulation, you need to randomize the phase of the stabilizer at the anticommuting index yourself. For instance, one can do:</p><pre><code class="language-julia">newstate, anticomindex, result = project!(state, projector)
if isnothing(result)
    newstate.phases[anticomindex] = rand([0x0,0x2])
end</code></pre><p>Or we can project on a commuting operator, hence no anticommuting terms (the index is zero), and the result is perfectly determined (-1, or in our convention to represent the phase, 0x2).</p><pre><code class="language-julia-repl">julia&gt; project!(copy(s), P&quot;-ZZI&quot;)
(- XXX
- Z_Z
- _ZZ, 0, 0x02)</code></pre><p>When the projection is consistent with the stabilizer (i.e. the measurement result is not <code>nothing</code>), this would trigger an expensive canonicalization procedure in order to calculate the measurement result (unless we are using more advanced data structures to represent the state, which are discussed later). If all you want to know is whether the projection is consistent with the stabilizer, but you do not care about the measurement result, you can skip the canonicalization and calculation of the result.</p><pre><code class="language-julia-repl">julia&gt; project!(copy(s), P&quot;-ZZI&quot;, keep_result=false)
(- XXX
+ ZZ_
- _ZZ, 0, nothing)</code></pre><p>Lastly, in either case, you can skip the calculation of the phases as well, if they are unimportant.</p><pre><code class="language-julia-repl">julia&gt; project!(copy(s), P&quot;ZZI&quot;, phases=false)
(- XXX
+ Z_Z
- _ZZ, 0, 0x00)</code></pre><h1 id="Partial-Traces"><a class="docs-heading-anchor" href="#Partial-Traces">Partial Traces</a><a id="Partial-Traces-1"></a><a class="docs-heading-anchor-permalink" href="#Partial-Traces" title="Permalink"></a></h1><p>Partial trace (using <a href="../API/#QuantumClifford.traceout!-Union{Tuple{T}, Tuple{Stabilizer,AbstractArray{T,1}}} where T&lt;:Integer"><code>traceout!</code></a>) over even a single qubit might cause many of them to decohere due to entanglement.</p><pre><code class="language-julia-repl">julia&gt; ghz = S&quot;XXX
               ZZ_
               _ZZ&quot;;

julia&gt; traceout!(ghz, [1])
+ _ZZ
+ ___
+ ___</code></pre><p>This is somewhat more elegant when the datastructure being used explicitly supports mixed states.</p><pre><code class="language-julia-repl">julia&gt; ghz = MixedStabilizer(S&quot;XXX
                               ZZ_
                               _ZZ&quot;);

julia&gt; traceout!(ghz, [1])
Rank 1 stabilizer
+ _ZZ</code></pre><h1 id="Generating-a-Pauli-Operator-with-Stabilizer-Generators"><a class="docs-heading-anchor" href="#Generating-a-Pauli-Operator-with-Stabilizer-Generators">Generating a Pauli Operator with Stabilizer Generators</a><a id="Generating-a-Pauli-Operator-with-Stabilizer-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-a-Pauli-Operator-with-Stabilizer-Generators" title="Permalink"></a></h1><p>The <a href="../API/#QuantumClifford.generate!-Tuple{PauliOperator,Stabilizer}"><code>generate!</code></a> function attempts to generate a Pauli operator by multiplying together the operators belonging to a given stabilizer (or reports their independence). This particular function requires the stabilizer to be already canonicalized.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZI
             -IZZ&quot;;

julia&gt; s = canonicalize!(s)
- XXX
- Z_Z
- _ZZ</code></pre><p>It modifies the Pauli operator in place, reducing it to identity if possible. The leftover phase is present to indicate if the phase itself could not have been canceled. The list of indices specifies which rows of the stabilizer were used to generated the desired Pauli operator.</p><pre><code class="language-julia-repl">julia&gt; generate!(P&quot;XYY&quot;, s)
(- ___, [1, 3])</code></pre><p>Phases can be neglected, for higher performance.</p><pre><code class="language-julia-repl">julia&gt; generate!(P&quot;XYY&quot;, s, phases=false)
(+ ___, [1, 3])</code></pre><p>If the Pauli operator can not be generated by the stabilizer, <code>nothing</code> value is returned.</p><pre><code class="language-julia-repl">julia&gt; generate!(P&quot;ZZZ&quot;, s)

julia&gt; generate!(P&quot;XZX&quot;, s)

julia&gt; generate!(P&quot;YYY&quot;, s)</code></pre><h1 id="Clifford-Operators"><a class="docs-heading-anchor" href="#Clifford-Operators">Clifford Operators</a><a id="Clifford-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Clifford-Operators" title="Permalink"></a></h1><p>The <a href="../API/#QuantumClifford.CliffordOperator"><code>CliffordOperator</code></a> structure represents a linear mapping between stabilizers (which should also preserve commutation relationships, but that is not checked at instantiation). A number of predefined Clifford operators are available.</p><pre><code class="language-julia-repl">julia&gt; Hadamard
X ⟼ + Z
Z ⟼ + X

julia&gt; Phase
X ⟼ + Y
Z ⟼ + Z

julia&gt; CNOT
X_ ⟼ + XX
_X ⟼ + _X
Z_ ⟼ + Z_
_Z ⟼ + ZZ

julia&gt; CliffordId
X ⟼ + X
Z ⟼ + Z</code></pre><p>Chaining and tensor products are possible. Same for qubit permutations.</p><pre><code class="language-julia-repl">julia&gt; Hadamard ⊗ Phase
X_ ⟼ + Z_
_X ⟼ + _Y
Z_ ⟼ + X_
_Z ⟼ + _Z

julia&gt; Hadamard * Phase
X ⟼ - Y
Z ⟼ + X

julia&gt; permute(CNOT, [2,1])
X_ ⟼ + X_
_X ⟼ + XX
Z_ ⟼ + ZZ
_Z ⟼ + _Z</code></pre><p>You can create custom Clifford operators with C-strings or with a list of Pauli operators.</p><pre><code class="language-julia-repl">julia&gt; C&quot;-ZZ
         +_Z
         -X_
         +XX&quot;
X_ ⟼ - ZZ
_X ⟼ + _Z
Z_ ⟼ - X_
_Z ⟼ + XX

julia&gt; CliffordColumnForm([P&quot;-ZZ&quot;, P&quot;_Z&quot;, P&quot;-X_&quot;, P&quot;XX&quot;])
X_ ⟼ - ZZ
_X ⟼ + _Z
Z_ ⟼ - X_
_Z ⟼ + XX</code></pre><p>Naturally, the operators can be applied to stabilizer states. This includes high performance in-place operations (and the phase can be neglected with <code>phases=false</code> for faster computation). For some uses, the alternative datastructure <a href="../API/#QuantumClifford.CliffordColumnForm"><code>CliffordColumnForm</code></a> might be more performant.</p><pre><code class="language-julia-repl">julia&gt; CNOT * S&quot;X_&quot;
+ XX

julia&gt; s = S&quot;X_&quot;;

julia&gt; apply!(s,CNOT)
+ XX</code></pre><p>Sparse applications where a small Clifford operator is applied only on a particular subset of a larger stabilizer is also possible.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;Z_YX&quot;;

julia&gt; apply!(s, CNOT, [4,2]) # Apply the CNOT on qubits 4 and 2
+ ZXYX</code></pre><p>Pauli operators act as Clifford operators too (but they are rather boring, as they only change signs).</p><pre><code class="language-julia-repl">julia&gt; P&quot;XII&quot; * S&quot;ZXX&quot;
- ZXX</code></pre><h1 id="Destabilizers"><a class="docs-heading-anchor" href="#Destabilizers">Destabilizers</a><a id="Destabilizers-1"></a><a class="docs-heading-anchor-permalink" href="#Destabilizers" title="Permalink"></a></h1><p>Slightly abusing the name: What we call &quot;destabilizers&quot; here is a stabilizer and its destabilizing operators saved together. They are implemented with the <a href="../API/#QuantumClifford.Destabilizer"><code>Destabilizer</code></a> object and are initialized from a stabilizer.</p><pre><code class="language-julia-repl">julia&gt; s=S&quot;-XXX
           -ZZI
           +IZZ&quot;;

julia&gt; d = Destabilizer(s)
+ Z__
+ X__
+ _X_
━━━━━
- XXX
- Z_Z
+ _ZZ</code></pre><p>They have convenience methods to extract only the stabilizer and destabilizer pieces:</p><pre><code class="language-julia-repl">julia&gt; stabilizerview(d)
- XXX
- Z_Z
+ _ZZ

julia&gt; destabilizerview(d)
+ Z__
+ X__
+ _X_</code></pre><p>Importantly commuting projections are much faster when tracking the destabilizer as canonicalization is not necessary (an <span>$\mathcal{O}(n^2)$</span> complexity because it avoids the expensive <span>$\mathcal{O}(n^3)$</span> canonicalization operation).</p><pre><code class="language-julia-repl">julia&gt; project!(d,P&quot;ZZI&quot;)
(+ Z__
+ X__
+ _X_
━━━━━
- XXX
- Z_Z
+ _ZZ, 0, 0x02)</code></pre><p>Non-commuting projections are just as fast as when using only stabilizers.</p><pre><code class="language-julia-repl">julia&gt; project!(d,P&quot;ZZZ&quot;)
(- XXX
+ _XX
+ X_X
━━━━━
+ ZZZ
- Z_Z
+ _ZZ, 1, nothing)</code></pre><p>Clifford operations can be applied the same way they are applied to stabilizers.</p><pre><code class="language-julia-repl">julia&gt; apply!(d,CNOT⊗Hadamard)
- X_Z
+ _XZ
+ XXZ
━━━━━
+ _ZX
- Z_X
+ ZZX</code></pre><h1 id="Mixed-States"><a class="docs-heading-anchor" href="#Mixed-States">Mixed States</a><a id="Mixed-States-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-States" title="Permalink"></a></h1><p>Both the <code>Stabilizer</code> and <code>Destabilizer</code> structures have more general forms that enable work with mixed stabilizer states. They are the <a href="../API/#QuantumClifford.MixedStabilizer"><code>MixedStabilizer</code></a> and <a href="../API/#QuantumClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> structures, described in <a href="../mixed/#Mixed-Stabilizer-States">Mixed States</a>. More information that can be seen in the <a href="../datastructures/#Choosing-Appropriate-Data-Structure">data structures page</a>, which expands upon the algorithms available for each structure.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« QuantumClifford.jl</a><a class="docs-footer-nextpage" href="../canonicalization/">Canonicalization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 17 December 2020 07:27">Thursday 17 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
