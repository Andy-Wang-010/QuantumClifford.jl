<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · SimpleClifford.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimpleClifford.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">SimpleClifford.jl</a></li><li class="current"><a class="toctext" href>Manual</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Pauli-Operators-1">Pauli Operators</a></li><li class="toplevel"><a class="toctext" href="#Stabilizers-1">Stabilizers</a></li><li class="toplevel"><a class="toctext" href="#Canonicalization-of-Stabilizers-1">Canonicalization of Stabilizers</a></li><li class="toplevel"><a class="toctext" href="#Projective-measurements-1">Projective measurements</a></li><li class="toplevel"><a class="toctext" href="#Generating-a-Pauli-operator-with-Stabilizer-generators-1">Generating a Pauli operator with Stabilizer generators</a></li><li class="toplevel"><a class="toctext" href="#Clifford-Operators-1">Clifford Operators</a></li><li class="toplevel"><a class="toctext" href="#Destabilizers-1">Destabilizers</a></li></ul></li><li><a class="toctext" href="../datastructures/">Datastructure Choice</a></li><li><a class="toctext" href="../API/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Manual</a></li></ul><a class="edit-page" href="https://github.com/Krastanov/SimpleClifford/blob/master/docs/src/manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><h1><a class="nav-anchor" id="Pauli-Operators-1" href="#Pauli-Operators-1">Pauli Operators</a></h1><p>The <a href="../API/#SimpleClifford.PauliOperator"><code>PauliOperator</code></a> object representes multi-qubit Pauli operator (<span>$±\{1,i\}\{I,Z,X,Y\}^{\otimes n}$</span>). It is stored in memory as a phase (a single byte where <code>0x0,0x1,0x2,0x3</code> corresponds to <span>$1,i,-1,-i$</span>) and two bit-arrays, for X and for Z components.</p><p>You can create them with a <code>P</code> string.</p><pre><code class="language-julia-repl">julia&gt; P&quot;-iXZ&quot;
-iXZ</code></pre><p>Or by specifying phase and X/Z components:</p><pre><code class="language-julia-repl">julia&gt; PauliOperator(0x0,Bool[0,1,0],Bool[0,0,1])
+ _XZ</code></pre><p>Both underscore and I can be used for identity.</p><pre><code class="language-julia-repl">julia&gt; P&quot;I_XYZ&quot;
+ __XYZ</code></pre><p>Multiplication with scalars or other Pauli operators works as expected, as well as tensor products of Pauli operators.</p><pre><code class="language-julia-repl">julia&gt; -1im*P&quot;X&quot;
-iX

julia&gt; P&quot;X&quot; * P&quot;Z&quot;
-iY

julia&gt; P&quot;X&quot; ⊗ P&quot;Z&quot;
+ XZ</code></pre><p>One can check for commutativity with <a href="../API/#SimpleClifford.comm-Tuple{PauliOperator,PauliOperator}"><code>comm</code></a>.</p><pre><code class="language-julia-repl">julia&gt; comm(P&quot;X&quot;,P&quot;Z&quot;)
0x01

julia&gt; comm(P&quot;XX&quot;,P&quot;ZZ&quot;)
0x00</code></pre><p>And check the phase of a product with <a href="../API/#SimpleClifford.prodphase-Tuple{AbstractArray{UInt64,1},AbstractArray{UInt64,1}}"><code>prodphase</code></a>.</p><pre><code class="language-julia-repl">julia&gt; prodphase(P&quot;X&quot;, P&quot;Z&quot;)
0x03

julia&gt; prodphase(P&quot;X&quot;, P&quot;iZ&quot;)
0x00

julia&gt; prodphase(P&quot;X&quot;,P&quot;Y&quot;)
0x01</code></pre><p>Indexing operations are available.</p><pre><code class="language-julia-repl">julia&gt; p = P&quot;IXYZ&quot;;

julia&gt; p[1], p[2], p[3], p[4]
((false, false), (true, false), (true, true), (false, true))

julia&gt; p = P&quot;III&quot;;

julia&gt; p[2] = (true, true);

julia&gt; p
+ _Y_</code></pre><p>Including fancy indexing:</p><pre><code class="language-julia-repl">julia&gt; P&quot;IXYZ&quot;[[2,3]]
+ XY

julia&gt; P&quot;IXYZ&quot;[[false,true,true,false]]
+ XY</code></pre><p>The operator is represented in memory by bit arrays (much denser than using byte arrays).</p><pre><code class="language-julia-repl">julia&gt; p = P&quot;-IXYZ&quot;;

julia&gt; p.nqbits, p.phase, p.xz
(4, 0x02, UInt64[0x0000000000000006, 0x000000000000000c])</code></pre><p>The convenience properties <code>xbit</code> and <code>zbit</code> give you Bool (GF2) vectors. TODO: this should be a separate function.</p><pre><code class="language-julia-repl">julia&gt; P&quot;XYZI&quot;.xbit
4-element BitArray{1}:
 1
 1
 0
 0</code></pre><h1><a class="nav-anchor" id="Stabilizers-1" href="#Stabilizers-1">Stabilizers</a></h1><p>A <a href="../API/#SimpleClifford.Stabilizer"><code>Stabilizer</code></a> object is a tableau of Pauli operators. When the tableau is meant to represent a (pure or mixed) stabilizer state, all of these operators should commute (but that is not enforced, rather <code>Stabilizer</code> is a generic tableau data structure). It is stored in memory as a phase list and a bit-matrix for X and Z components. It can be instantiated by an <code>S</code> string, or with a number of different constructors.</p><pre><code class="language-julia-repl">julia&gt; S&quot;-XX
         +ZZ&quot;
- XX
+ ZZ

julia&gt; Stabilizer([P&quot;-XX&quot;,P&quot;+ZZ&quot;])
- XX
+ ZZ

julia&gt; Stabilizer([0x2, 0x0],
                  Bool[1 1;
                       0 0],
                  Bool[0 0;
                       1 1])
- XX
+ ZZ</code></pre><p>Direct sums can be performed,</p><pre><code class="language-julia-repl">julia&gt; S&quot;-XX&quot; ⊕ S&quot;ZZ&quot;
- XX__
+ __ZZ</code></pre><p>Indexing operations are available, including fancy indexing, but 2D indexing, into the Pauli operators is not implemented (TODO).</p><p>Consistency at creation is not verified so nonsensical stabilizers can be created, both in terms of content and shape.</p><pre><code class="language-julia-repl">julia&gt; S&quot;iX
         +Z&quot;
+iX
+ Z</code></pre><p>Similarly to the Pauli operators, a bit array representation is used.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZI
             -IZZ&quot;
- XXX
+ ZZ_
- _ZZ

julia&gt; s.phases, s.nqbits, s.xzs
(UInt8[0x02, 0x00, 0x02], 3, UInt64[0x0000000000000007 0x0000000000000000; 0x0000000000000000 0x0000000000000003; 0x0000000000000000 0x0000000000000006])</code></pre><p>And there are convenience functions that can extract the corresponding binary check matrix.</p><pre><code class="language-julia-repl">julia&gt; stab_to_gf2(s)
3×6 BitArray{2}:
 1  1  1  0  0  0
 0  0  0  1  1  0
 0  0  0  0  1  1</code></pre><h1><a class="nav-anchor" id="Canonicalization-of-Stabilizers-1" href="#Canonicalization-of-Stabilizers-1">Canonicalization of Stabilizers</a></h1><p>Canonicalization (akin to Gaussian elimination over F(2,2)) is implemented in the <a href="../API/#SimpleClifford.canonicalize!-Tuple{Stabilizer}"><code>canonicalize!</code></a> function.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZX
             +III&quot;;

julia&gt; canonicalize!(s)
+ YY_
+ ZZX
+ ___</code></pre><p>If phases are inconsequential, the operations can be faster by not tracking and updating them.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZX
             +III&quot;;

julia&gt; canonicalize!(s; phases=false)
- YY_
+ ZZX
+ ___</code></pre><p>These operations are in place (as customarily signified by &quot;!&quot;).</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZX
             +III&quot;;

julia&gt; canonicalize!(s; phases=false);

julia&gt; s
- YY_
+ ZZX
+ ___</code></pre><h1><a class="nav-anchor" id="Projective-measurements-1" href="#Projective-measurements-1">Projective measurements</a></h1><p>To observe the effect of different projections, we will start with a GHZ state.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZI
             -IZZ&quot;;</code></pre><p>The <a href="../API/#SimpleClifford.project!-Tuple{Stabilizer,PauliOperator}"><code>project!</code></a> function returns the new stabilizer, the index where the anticommutation was detected, and the result of the projection (<code>nothing</code> being an undetermined result). For instance here we project on an operator that does not commute with all stabilizer generators.</p><pre><code class="language-julia-repl">julia&gt; project!(copy(s), P&quot;ZII&quot;)
(+ Z__
+ ZZ_
- _ZZ, 1, nothing)</code></pre><p>Or we can project on a commuting operator, hence no anticommuting terms (the index is zero), and the result is perfectly determined (-1, or in our convention to represent the phase, 0x2).</p><pre><code class="language-julia-repl">julia&gt; project!(copy(s), P&quot;-ZZI&quot;)
(- XXX
- Z_Z
- _ZZ, 0, 0x02)</code></pre><p>When the projection is consistent with the stabilizer (i.e. the measurement result is not <code>nothing</code>), this would trigger an expensive canonicalization procedure in order to calculate the measurement result (unless we are using more advanced data structures to represent the state, which are discussed later). If all you want to know is whether the projection is consistent with the stabilizer, but you do not care about the measurement result, you can skip the canonicalization and calculation of the result.</p><pre><code class="language-julia-repl">julia&gt; project!(copy(s), P&quot;-ZZI&quot;, keep_result=false)
(- XXX
+ ZZ_
- _ZZ, 0, nothing)</code></pre><p>Lastly, in either case, you can skip the calculation of the phases as well, if they are unimportant.</p><pre><code class="language-julia-repl">julia&gt; project!(copy(s), P&quot;ZZI&quot;, phases=false)
(- XXX
+ Z_Z
- _ZZ, 0, 0x00)</code></pre><h1><a class="nav-anchor" id="Generating-a-Pauli-operator-with-Stabilizer-generators-1" href="#Generating-a-Pauli-operator-with-Stabilizer-generators-1">Generating a Pauli operator with Stabilizer generators</a></h1><p>The <a href="../API/#SimpleClifford.generate!-Tuple{PauliOperator,Stabilizer}"><code>generate!</code></a> function attempts to generate a Pauli operator by multiplying together the operators belonging to a given stabilizer (or reports their independence). This particular function requires the stabilizer to be already canonicalized.</p><pre><code class="language-julia-repl">julia&gt; s = S&quot;-XXX
             +ZZI
             -IZZ&quot;;

julia&gt; s = canonicalize!(s)
- XXX
- Z_Z
- _ZZ</code></pre><p>It modifies the Pauli operator in place, reducing it to identity if possible. The leftover phase is present to indicate if the phase itself could not have been canceled. The list of indices specifies which rows of the stabilizer were used to generated the desired Pauli operator.</p><pre><code class="language-julia-repl">julia&gt; generate!(P&quot;XYY&quot;, s)
(- ___, [1, 3])</code></pre><p>Phases can be neglected, for higher performance.</p><pre><code class="language-julia-repl">julia&gt; generate!(P&quot;XYY&quot;, s, phases=false)
(+ ___, [1, 3])</code></pre><p>If the Pauli operator can not be generated by the stabilizer, <code>nothing</code> value is returned.</p><pre><code class="language-julia-repl">julia&gt; generate!(P&quot;ZZZ&quot;, s)

julia&gt; generate!(P&quot;XZX&quot;, s)

julia&gt; generate!(P&quot;YYY&quot;, s)</code></pre><h1><a class="nav-anchor" id="Clifford-Operators-1" href="#Clifford-Operators-1">Clifford Operators</a></h1><p>The <a href="../API/#SimpleClifford.CliffordOperator"><code>CliffordOperator</code></a> structure represents a linear mapping between stabilizers (which should also preserve commutation relationships, but that is not checked at instantiation). A number of predefined Clifford operators are available.</p><pre><code class="language-julia-repl">julia&gt; Hadamard
X ⟼ + Z
Z ⟼ + X

julia&gt; Phase
X ⟼ + Y
Z ⟼ + Z

julia&gt; CNOT
X_ ⟼ + XX
_X ⟼ + _X
Z_ ⟼ + Z_
_Z ⟼ + ZZ

julia&gt; CliffordId
X ⟼ + X
Z ⟼ + Z</code></pre><p>Chaining and tensor products are possible (but slow, improving which is on the TODO list). Same for qubit permutations.</p><pre><code class="language-julia-repl">julia&gt; Hadamard ⊗ Phase
X_ ⟼ + Z_
_X ⟼ + _Y
Z_ ⟼ + X_
_Z ⟼ + _Z

julia&gt; Hadamard * Phase
X ⟼ - Y
Z ⟼ + X

julia&gt; permute(CNOT, [2,1])
X_ ⟼ + X_
_X ⟼ + XX
Z_ ⟼ + ZZ
_Z ⟼ + _Z</code></pre><p>You can create custom Clifford operators with C-strings or with a list of Pauli operators. It is on the TODO list to be able to create them by using a Stabilizer or by using boolean matrices.</p><pre><code class="language-julia-repl">julia&gt; C&quot;-ZZ
         +_Z
         -X_
         +XX&quot;
X_ ⟼ - ZZ
_X ⟼ + _Z
Z_ ⟼ - X_
_Z ⟼ + XX

julia&gt; CliffordOperator([P&quot;-ZZ&quot;, P&quot;_Z&quot;, P&quot;-X_&quot;, P&quot;XX&quot;])
X_ ⟼ - ZZ
_X ⟼ + _Z
Z_ ⟼ - X_
_Z ⟼ + XX</code></pre><p>Naturally, the operators can be applied to stabilizer states. This includes high performance in-place operations (and the phase can be neglected with <code>phases=false</code> for faster computation).</p><pre><code class="language-julia-repl">julia&gt; CNOT * S&quot;X_&quot;
+ XX

julia&gt; s = S&quot;X_&quot;;

julia&gt; apply!(s,CNOT)
+ XX</code></pre><p>It is on the TODO list to permit small Clifford operators can be applied to large stabilizers by specifying the qubit indices.</p><p>Pauli operators act as Clifford operators too (but they are rather boring, as they only change signs).</p><pre><code class="language-julia-repl">julia&gt; P&quot;XII&quot; * S&quot;ZXX&quot;
- ZXX</code></pre><h1><a class="nav-anchor" id="Destabilizers-1" href="#Destabilizers-1">Destabilizers</a></h1><p>Slightly abusing the name: What we call &quot;destabilizers&quot; here is a stabilizer and its destabilizing operators saved together. They are implmented with the <a href="../API/#SimpleClifford.Destabilizer"><code>Destabilizer</code></a> object and are initialized from a stabilizer.</p><pre><code class="language-julia-repl">julia&gt; s=S&quot;-XXX
           -ZZI
           +IZZ&quot;;

julia&gt; d = Destabilizer(s)
+ Z__
+ X__
+ _X_
━━━━━
- XXX
- Z_Z
+ _ZZ</code></pre><p>They have convenience properties to extract only the stabilizer and destabilizer pieces:</p><pre><code class="language-julia-repl">julia&gt; d.stabilizer
- XXX
- Z_Z
+ _ZZ

julia&gt; d.destabilizer
+ Z__
+ X__
+ _X_</code></pre><p>Importantly commuting projections are much faster when tracking the destabilizer as canonicalization is not necessary (an <span>$\mathcal{O}(n^2)$</span> because it avoids the expensive <span>$\mathcal{O}(n^3)$</span> canonicalization operation.</p><pre><code class="language-julia-repl">julia&gt; project!(d,P&quot;ZZI&quot;)
(+ Z__
+ X__
+ _X_
━━━━━
- XXX
- Z_Z
+ _ZZ, 0, 0x02)</code></pre><p>Non-commuting projections are just as fast as when using only stabilizers.</p><pre><code class="language-julia-repl">julia&gt; project!(d,P&quot;ZZZ&quot;)
(- XXX
+ _XX
+ X_X
━━━━━
+ ZZZ
- Z_Z
+ _ZZ, 1, nothing)</code></pre><p>Clifford operations can be applied the same way they are applied to stabilizers.</p><pre><code class="language-julia-repl">julia&gt; apply!(d,CNOT⊗Hadamard)
- X_Z
+ _XZ
+ XXZ
━━━━━
+ _ZX
- Z_X
+ ZZX</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">SimpleClifford.jl</span></a><a class="next" href="../datastructures/"><span class="direction">Next</span><span class="title">Datastructure Choice</span></a></footer></article></body></html>
