<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Datastructure Choice · SimpleClifford.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimpleClifford.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">SimpleClifford.jl</a></li><li><a class="toctext" href="../manual/">Manual</a></li><li><a class="toctext" href="../mixed/">Mixed States</a></li><li class="current"><a class="toctext" href>Datastructure Choice</a><ul class="internal"></ul></li><li><a class="toctext" href="../API/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Datastructure Choice</a></li></ul><a class="edit-page" href="https://github.com/Krastanov/SimpleClifford/blob/master/docs/src/datastructures.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Datastructure Choice</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Choosing-Appropriate-Data-Structure-1" href="#Choosing-Appropriate-Data-Structure-1">Choosing Appropriate Data Structure</a></h1><p>There are four different data structures used to represent stabilizer states. If you will never need projective measurements you probably would want to use <a href="../API/#SimpleClifford.Stabilizer"><code>Stabilizer</code></a>. If you require projective measurements, but only on pure states, <a href="../API/#SimpleClifford.Destabilizer"><code>Destabilizer</code></a> should be the appropriate data structure. If mixed stabilizer states are involved, <a href="../API/#SimpleClifford.MixedStabilizer"><code>MixedStabilizer</code></a> would be necessary.</p><p><a href="../API/#SimpleClifford.Stabilizer"><code>Stabilizer</code></a> is simply a list of Pauli operators in a tableau form. As a data structure it does not enforce the requirements for a pure stabilizer state (the rows of the tableau do not necessarily commute, nor are they forced to be Hermitian; the tableau might be underdetermined, redundant, or contradictory). It is up to the user to ensure that the initial values in the tableau are meaningful and consistent.</p><p><a href="../API/#SimpleClifford.canonicalize!-Tuple{Stabilizer}"><code>canonicalize!</code></a>, <a href="../API/#SimpleClifford.project!-Tuple{Stabilizer,PauliOperator}"><code>project!</code></a>, and <a href="../API/#SimpleClifford.generate!-Tuple{PauliOperator,Stabilizer}"><code>generate!</code></a> can accept an under determined (mixed state) <code>Stabilizer</code> instance and operate correctly. <code>canonicalize!</code> can also accept a redundant <code>Stabilizer</code> (i.e. not all rows are independent), leaving as many identity rows at the bottom of the canonicalized tableau as the number of redundant stabilizers in the initial tableau.</p><p><code>canonicalize!</code> takes <span>$\mathcal{O}(n^3)$</span> steps. <code>generate!</code> expects a canonicalized input and then takes <span>$\mathcal{O}(n^2)$</span> steps. <code>project!</code> takes <span>$\mathcal{O}(n^3)$</span> for projecting on commuting operators due to the need to call <code>canonicalize!</code> and <code>generate!</code>. If the projections is on an anticommuting operator (or if <code>keep_result=false</code>) then it takes <span>$\mathcal{O}(n^2)$</span> steps.</p><p><a href="../API/#SimpleClifford.MixedStabilizer"><code>MixedStabilizer</code></a> provides explicit tracking of the rank of the mixed state and works properly when the projection is on a commuting operator not in the stabilizer (see table below for details). Otherwise it has the same performance as <code>Stabilizer</code>.</p><p>The canonicalization can be made unnecessary if we track the destabilizer generators. There are two data structures capable of that.</p><p><a href="../API/#SimpleClifford.Destabilizer"><code>Destabilizer</code></a> stores both the destabilizer and stabilizer states. <code>project!</code> called on it never requires a stabilizer canonicalization, hence it runs in <span>$\mathcal{O}(n^2)$</span>. However, <code>project!</code> will raise an exception if you try to project on a commuting state that is not in the stabilizer as that would be an expensive operation (<span>$\mathcal{O}(n^3)$</span>).</p><p><a href="../API/#SimpleClifford.MixedDestabilizer"><code>MixedDestabilizer</code></a> tracks both the destabilizer operators and the logical operators in addition to the stabilizer generators. It does not require canonicalization for measurements and its <code>project!</code> operations always takes <span>$\mathcal{O}(n^3)$</span>.</p><table><tr><th style="text-align: right">projection</th><th style="text-align: right"><code>Stabilizer</code></th><th style="text-align: right"><code>MixedStabilizer</code></th><th style="text-align: right"><code>Destabilizer</code></th><th style="text-align: right"><code>MixedDestabilizer</code></th></tr><tr><td style="text-align: right">on anticommuting operator</td><td style="text-align: right">correct result in <span>$\mathcal{O}(n^2)$</span> steps</td><td style="text-align: right">same as <code>Stabilizer</code></td><td style="text-align: right">same as <code>Stabilizer</code></td><td style="text-align: right">same as <code>Stabilizer</code></td></tr><tr><td style="text-align: right">on commuting operator in the stabilizer</td><td style="text-align: right"><span>$\mathcal{O}(n^3)$</span>, or <span>$\mathcal{O}(n^2)$</span> if <code>keep_result=false</code></td><td style="text-align: right"><span>$\mathcal{O}(n^3)$</span></td><td style="text-align: right"><span>$\mathcal{O}(n^2)$</span> if the state is pure, throws exception otherwise</td><td style="text-align: right"><span>$\mathcal{O}(n^2)$</span></td></tr><tr><td style="text-align: right">on commuting operator out of the stabilizer<a href="#footnote-1">[1]</a></td><td style="text-align: right"><span>$\mathcal{O}(n^3)$</span>, but the user needs to manually include the new operator to the stabilizer</td><td style="text-align: right"><span>$\mathcal{O}(n^3)$</span></td><td style="text-align: right">not applicable if the state is pure, throws an error otherwise</td><td style="text-align: right"><span>$\mathcal{O}(n^3)$</span></td></tr></table><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>This can occur only if the state being projected is mixed. Both <code>Stabilizer</code> and <code>Destabilizer</code> can be used for mixed states by simply providing fewer stabilizer generators than qubits at initialization. This can be useful for low-level code that tries to avoid the extra memory cost of using <code>MixedStabilizer</code> and <code>MixedDestabilizer</code> but should be avoided otherwise. <code>project!</code> works correctly or raises an explicit warning on all 4 data structures.</p></div><footer><hr/><a class="previous" href="../mixed/"><span class="direction">Previous</span><span class="title">Mixed States</span></a><a class="next" href="../API/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
