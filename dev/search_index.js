var documenterSearchIndex = {"docs":
[{"location":"tutandpub/#Tutorials-and-Publications","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"","category":"section"},{"location":"tutandpub/","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"This list has a number of notebooks with tutorials, examples, and reproduction of published results (some of these results originally obtained with this very library).","category":"page"},{"location":"tutandpub/","page":"Tutorials and Publications","title":"Tutorials and Publications","text":"Quantum coding with low-depth random circuits (arXiv:2010.09775).\nComparing the Monte Carlo and Perturbative method for noisy circuit simulations.\nShowcasing symbolic perturbative expansions of noisy circuits","category":"page"},{"location":"noisycircuits_API/#Full-API-(autogenerated)","page":"API","title":"Full API (autogenerated)","text":"","category":"section"},{"location":"noisycircuits_API/","page":"API","title":"API","text":"This is experimental functionality with an unstable API.","category":"page"},{"location":"noisycircuits_API/","page":"API","title":"API","text":"Modules = [QuantumClifford.Experimental.NoisyCircuits]","category":"page"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits","text":"A module for simulating noisy Clifford circuits.\n\n\n\n\n\n","category":"module"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.statuses","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.statuses","text":"A dictionary of possible statuses returned by applyop!.\n\n\n\n\n\n","category":"constant"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.BellMeasurement","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.BellMeasurement","text":"A Bell measurement performing the correlation measurement corresponding to the given paulis projections on the qubits at the selected indices.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.BellMeasurementAndNoisyReset","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.BellMeasurementAndNoisyReset","text":"Performing a Bell measurement followed by resetting the measured qubits to the given state resetto followed by the same qubits being affected by the given noise.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.BellMeasurementAndReset","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.BellMeasurementAndReset","text":"Performing a Bell measurement followed by resetting the measured qubits to the given state resetto.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.NoiseOp","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.NoiseOp","text":"An operator that applies the given noise model to the qubits at the selected indices.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.NoiseOpAll","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.NoiseOpAll","text":"An operator that applies the given noise model to all qubits.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.NoisyBellMeasurement","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.NoisyBellMeasurement","text":"A perfect Bell measurement performed after the application of the given noise on the measured qubits.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.NoisyGate","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.NoisyGate","text":"A gate consisting of the given noise applied after the given perfect Clifford gate.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.SparseGate","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.SparseGate","text":"A Clifford gate, applying the given cliff operator to the qubits at the selected indices.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.UnbiasedUncorrelatedNoise","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.UnbiasedUncorrelatedNoise","text":"Depolarization noise model with total probability of error 3*errprobthird.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.VerifyOp","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.VerifyOp","text":"A \"probe\" to verify that the state of the qubits corresponds to a desired good_state, e.g. at the end of the execution of a circuit.\n\n\n\n\n\n","category":"type"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.affectedqubits","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.affectedqubits","text":"A method giving the qubits acted upon by a given operation. Part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.applynoise!","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.applynoise!","text":"A method modifying a given state by applying the corresponding noise model. Non-deterministic, part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.applynoise_branches","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.applynoise_branches","text":"Compute all possible new states after the application of the given noise model. Reports the probability of each one of them. Deterministic, part of the Noise interface.\n\n\n\n\n\n","category":"function"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.applyop!","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.applyop!","text":"A method modifying a given state by applying the given operation. Non-deterministic, part of the Monte Carlo interface.\n\n\n\n\n\n","category":"function"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.applyop_branches","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.applyop_branches","text":"Compute all possible new states after the application of the given operator. Reports the probability of each one of them. Deterministic, part of the Perturbative Expansion interface.\n\n\n\n\n\n","category":"function"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.mctrajectories-Tuple{Stabilizer,AbstractArray{QuantumClifford.Experimental.NoisyCircuits.Operation,1}}","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.mctrajectories","text":"Run multiple Monte Carlo trajectories and report the aggregate final statuses of each.\n\n\n\n\n\n","category":"method"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.mctrajectory!-Tuple{Stabilizer,AbstractArray{QuantumClifford.Experimental.NoisyCircuits.Operation,1}}","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.mctrajectory!","text":"Run a single Monte Carlo sample, starting with (and modifying) initialstate by applying the given circuit. Uses applyop! under the hood.\n\n\n\n\n\n","category":"method"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.petrajectories-Tuple{Any,Any}","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.petrajectories","text":"Run a perturbative expansion to a given order. This is the main public fuction for the perturbative expansion approach.\n\n\n\n\n\n","category":"method"},{"location":"noisycircuits_API/#QuantumClifford.Experimental.NoisyCircuits.petrajectory-Tuple{Any,Any}","page":"API","title":"QuantumClifford.Experimental.NoisyCircuits.petrajectory","text":"Run a perturbative expansion to a given order. Uses applyop_branches under the hood.\n\n\n\n\n\n","category":"method"},{"location":"noisycircuits_perturb/#Perturbative-expansions-for-simulating-noisy-Clifford-circuits","page":"Leading-order Expansions","title":"Perturbative expansions for simulating noisy Clifford circuits","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"DocTestSetup = quote\n    using QuantumClifford\n    using QuantumClifford.Experimental.NoisyCircuits\nend","category":"page"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"Import with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"This module enables the simulation of noisy Clifford circuits through a perturbative expansion in the noise parameter (assuming the noise is small). Instead of simulating many Monte Carlo trajectories, only the leading order trajectories are exhaustively enumerated and simulated.","category":"page"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"Here is an example of a purification circuit:","category":"page"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\ngood_bell_state = S\"XX\n                    ZZ\"\ncanonicalize_rref!(good_bell_state)\ninitial_state = good_bell_state⊗good_bell_state\n\ng1 = SparseGate(CNOT, [1,3]) # CNOT between qubit 1 and qubit 3 (both with Alice)\ng2 = SparseGate(CNOT, [2,4]) # CNOT between qubit 2 and qubit 4 (both with Bob)\nm = BellMeasurement([X,X],[3,4]) # Bell measurement on qubit 3 and 4\nv = VerifyOp(good_bell_state,[1,2]) # Verify that qubit 1 and 2 indeed form a good Bell pair\nepsilon = 0.01 # The error rate\nn = NoiseOpAll(UnbiasedUncorrelatedNoise(epsilon))\n\n# This circuit performs a depolarization at rate `epsilon` to all qubits,\n# then bilater CNOT operations\n# then a Bell measurement\n# followed by checking whether the final result indeed corresponds to the correct Bell pair.\ncircuit = [n,g1,g2,m,v]\n\npetrajectories(initial_state, circuit)","category":"page"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"For more examples, see the notebook comparing the Monte Carlo and Perturbative method.","category":"page"},{"location":"noisycircuits_perturb/#Symbolic-expansions","page":"Leading-order Expansions","title":"Symbolic expansions","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"The perturbative expansion method works with symbolic variables as well. One can use any of the symbolic libraries available in Julia and simply plug symbolic parameters in lieu of numeric parameters. A detailed example is available as a jupyter notebook.","category":"page"},{"location":"noisycircuits_perturb/#Interface","page":"Leading-order Expansions","title":"Interface","text":"","category":"section"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"applyop_branches!(s::Stabilizer, g::Operation; max_order=1)::Vector{Tuple{Stabilizer,Int,Real,Int}} where the first Int is the status of the operation, the Real is the probability for that branch, and the second Int is the order of that branch.","category":"page"},{"location":"noisycircuits_perturb/","page":"Leading-order Expansions","title":"Leading-order Expansions","text":"There is also applynoise_branches! which is convenient for the NoisyGate and NoisyMeasurement and so on, but you can also just make up your own noise operator simply by implementing applyop_branches! for it.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using QuantumClifford\nend","category":"page"},{"location":"manual/#Pauli-Operators","page":"Manual","title":"Pauli Operators","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The PauliOperator object representes multi-qubit Pauli operator (1iIZXY^otimes n). It is stored in memory as a phase (a single byte where 0x0,0x1,0x2,0x3 corresponds to 1i-1-i) and two bit-arrays, for X and for Z components.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can create them with a P string.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> P\"-iXZ\"\n-iXZ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Or by specifying phase and X/Z components:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> PauliOperator(0x0,Bool[0,1,0],Bool[0,0,1])\n+ _XZ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Both underscore and I can be used for identity.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> P\"I_XYZ\"\n+ __XYZ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Multiplication with scalars or other Pauli operators works as expected, as well as tensor products of Pauli operators.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> -1im*P\"X\"\n-iX\n\njulia> P\"X\" * P\"Z\"\n-iY\n\njulia> P\"X\" ⊗ P\"Z\"\n+ XZ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One can check for commutativity with comm.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> comm(P\"X\",P\"Z\")\n0x01\n\njulia> comm(P\"XX\",P\"ZZ\")\n0x00","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"And check the phase of a product with prodphase.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> prodphase(P\"X\", P\"Z\")\n0x03\n\njulia> prodphase(P\"X\", P\"iZ\")\n0x00\n\njulia> prodphase(P\"X\",P\"Y\")\n0x01","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Indexing operations are available.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> p = P\"IXYZ\";\n\njulia> p[1], p[2], p[3], p[4]\n((false, false), (true, false), (true, true), (false, true))\n\njulia> p = P\"III\";\n\njulia> p[2] = (true, true);\n\njulia> p\n+ _Y_","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Including fancy indexing:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> P\"IXYZ\"[[2,3]]\n+ XY\n\njulia> P\"IXYZ\"[[false,true,true,false]]\n+ XY","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The operator is represented in memory by bit arrays (much denser than using byte arrays).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> p = P\"-IXYZ\";\n\njulia> p.nqubits, p.xz\n(4, UInt64[0x0000000000000006, 0x000000000000000c])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Views that give just the X or Z components of the xz bitarray are available through xview and zview.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> xview(P\"XYZI\")\n1-element view(::Array{UInt64,1}, 1:1) with eltype UInt64:\n 0x0000000000000003","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The convenience methods xbit and zbit give you Bool (GF2) vectors.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> xbit(P\"XYZI\")\n4-element BitArray{1}:\n 1\n 1\n 0\n 0","category":"page"},{"location":"manual/#Stabilizers","page":"Manual","title":"Stabilizers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"A Stabilizer object is a tableau of Pauli operators. When the tableau is meant to represent a (pure or mixed) stabilizer state, all of these operators should commute (but that is not enforced, rather Stabilizer is a generic tableau data structure). It is stored in memory as a phase list and a bit-matrix for X and Z components. It can be instantiated by an S string, or with a number of different constructors.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For data structures that build upon this tableau representation to track other useful information, consider Destabilizer, MixedStabilizer, and MixedDestabilizer. See also the data structures discussion page.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> S\"-XX\n         +ZZ\"\n- XX\n+ ZZ\n\njulia> Stabilizer([P\"-XX\",P\"+ZZ\"])\n- XX\n+ ZZ\n\njulia> Stabilizer([0x2, 0x0],\n                  Bool[1 1;\n                       0 0],\n                  Bool[0 0;\n                       1 1])\n- XX\n+ ZZ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Direct sums can be performed,","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> S\"-XX\" ⊗ S\"ZZ\"\n- XX__\n+ __ZZ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Indexing operations are available, including fancy indexing. Be careful about how phase information gets transferred during sub-indexing.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XYZ\n             -ZIX\n             +XIZ\";\n\njulia> s[1]\n- XYZ\n\njulia> s[1,2]\n(true, true)\n\njulia> s[[3,1]]\n+ X_Z\n- XYZ\n\njulia> s[[3,1],[2]]\n+ _\n- Y","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Consistency at creation is not verified so nonsensical stabilizers can be created, both in terms of content and shape.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> S\"iX\n         +Z\"\n+iX\n+ Z","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Similarly to the Pauli operators, a bit array representation is used.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\"\n- XXX\n+ ZZ_\n- _ZZ\n\njulia> s.phases, s.nqubits, s.xzs\n(UInt8[0x02, 0x00, 0x02], 3, UInt64[0x0000000000000007 0x0000000000000000; 0x0000000000000000 0x0000000000000003; 0x0000000000000000 0x0000000000000006])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"And there are convenience functions that can extract the corresponding binary check matrix.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> stab_to_gf2(s)\n3×6 BitArray{2}:\n 1  1  1  0  0  0\n 0  0  0  1  1  0\n 0  0  0  0  1  1","category":"page"},{"location":"manual/#Canonicalization-of-Stabilizers","page":"Manual","title":"Canonicalization of Stabilizers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Canonicalization (akin to Gaussian elimination over F(2,2)) is implemented in the canonicalize! function. Besides the default canonicalization prescription, alternative ones are available as described in the canonicalization page.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s)\n+ YY_\n+ ZZX\n+ ___","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If phases are inconsequential, the operations can be faster by not tracking and updating them.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s; phases=false)\n- YY_\n+ ZZX\n+ ___","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"These operations are in place (as customarily signified by \"!\").","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZX\n             +III\";\n\njulia> canonicalize!(s; phases=false);\n\njulia> s\n- YY_\n+ ZZX\n+ ___","category":"page"},{"location":"manual/#Projective-Measurements","page":"Manual","title":"Projective Measurements","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To observe the effect of different projections, we will start with a GHZ state.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\";","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The project! function returns the new stabilizer, the index where the anticommutation was detected, and the result of the projection (nothing being an undetermined result). For instance here we project on an operator that does not commute with all stabilizer generators.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"ZII\")\n(+ Z__\n+ ZZ_\n- _ZZ, 1, nothing)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Importantly, when there is an undetermined result, we return nothing and leave the phase of the new stabilizer the same as the phase of the projection operator. If you want to perform a Monte Carlo simulation, you need to randomize the phase of the stabilizer at the anticommuting index yourself. For instance, one can do:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"newstate, anticomindex, result = project!(state, projector)\nif isnothing(result)\n    newstate.phases[anticomindex] = rand([0x0,0x2])\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Or we can project on a commuting operator, hence no anticommuting terms (the index is zero), and the result is perfectly determined (-1, or in our convention to represent the phase, 0x2).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"-ZZI\")\n(- XXX\n- Z_Z\n- _ZZ, 0, 0x02)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When the projection is consistent with the stabilizer (i.e. the measurement result is not nothing), this would trigger an expensive canonicalization procedure in order to calculate the measurement result (unless we are using more advanced data structures to represent the state, which are discussed later). If all you want to know is whether the projection is consistent with the stabilizer, but you do not care about the measurement result, you can skip the canonicalization and calculation of the result.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"-ZZI\", keep_result=false)\n(- XXX\n+ ZZ_\n- _ZZ, 0, nothing)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Lastly, in either case, you can skip the calculation of the phases as well, if they are unimportant.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> project!(copy(s), P\"ZZI\", phases=false)\n(- XXX\n+ Z_Z\n- _ZZ, 0, 0x00)","category":"page"},{"location":"manual/#Partial-Traces","page":"Manual","title":"Partial Traces","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Partial trace (using traceout!) over even a single qubit might cause many of them to decohere due to entanglement.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> ghz = S\"XXX\n               ZZ_\n               _ZZ\";\n\njulia> traceout!(ghz, [1])\n+ _ZZ\n+ ___\n+ ___","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This is somewhat more elegant when the datastructure being used explicitly supports mixed states.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> ghz = MixedStabilizer(S\"XXX\n                               ZZ_\n                               _ZZ\");\n\njulia> traceout!(ghz, [1])\nRank 1 stabilizer\n+ _ZZ","category":"page"},{"location":"manual/#Generating-a-Pauli-Operator-with-Stabilizer-Generators","page":"Manual","title":"Generating a Pauli Operator with Stabilizer Generators","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The generate! function attempts to generate a Pauli operator by multiplying together the operators belonging to a given stabilizer (or reports their independence). This particular function requires the stabilizer to be already canonicalized.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = S\"-XXX\n             +ZZI\n             -IZZ\";\n\njulia> s = canonicalize!(s)\n- XXX\n- Z_Z\n- _ZZ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It modifies the Pauli operator in place, reducing it to identity if possible. The leftover phase is present to indicate if the phase itself could not have been canceled. The list of indices specifies which rows of the stabilizer were used to generated the desired Pauli operator.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"XYY\", s)\n(- ___, [1, 3])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Phases can be neglected, for higher performance.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"XYY\", s, phases=false)\n(+ ___, [1, 3])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If the Pauli operator can not be generated by the stabilizer, nothing value is returned.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> generate!(P\"ZZZ\", s)\n\njulia> generate!(P\"XZX\", s)\n\njulia> generate!(P\"YYY\", s)","category":"page"},{"location":"manual/#Clifford-Operators","page":"Manual","title":"Clifford Operators","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The CliffordOperator structure represents a linear mapping between stabilizers (which should also preserve commutation relationships, but that is not checked at instantiation). A number of predefined Clifford operators are available.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> Hadamard\nX ⟼ + Z\nZ ⟼ + X\n\njulia> Phase\nX ⟼ + Y\nZ ⟼ + Z\n\njulia> CNOT\nX_ ⟼ + XX\n_X ⟼ + _X\nZ_ ⟼ + Z_\n_Z ⟼ + ZZ\n\njulia> CliffordId\nX ⟼ + X\nZ ⟼ + Z","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Chaining and tensor products are possible. Same for qubit permutations.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> Hadamard ⊗ Phase\nX_ ⟼ + Z_\n_X ⟼ + _Y\nZ_ ⟼ + X_\n_Z ⟼ + _Z\n\njulia> Hadamard * Phase\nX ⟼ - Y\nZ ⟼ + X\n\njulia> permute(CNOT, [2,1])\nX_ ⟼ + X_\n_X ⟼ + XX\nZ_ ⟼ + ZZ\n_Z ⟼ + _Z","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can create custom Clifford operators with C-strings or with a list of Pauli operators.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> C\"-ZZ\n         +_Z\n         -X_\n         +XX\"\nX_ ⟼ - ZZ\n_X ⟼ + _Z\nZ_ ⟼ - X_\n_Z ⟼ + XX\n\njulia> CliffordColumnForm([P\"-ZZ\", P\"_Z\", P\"-X_\", P\"XX\"])\nX_ ⟼ - ZZ\n_X ⟼ + _Z\nZ_ ⟼ - X_\n_Z ⟼ + XX","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Naturally, the operators can be applied to stabilizer states. This includes high performance in-place operations (and the phase can be neglected with phases=false for faster computation). For some uses, the alternative datastructure CliffordColumnForm might be more performant.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> CNOT * S\"X_\"\n+ XX\n\njulia> s = S\"X_\";\n\njulia> apply!(s,CNOT)\n+ XX","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Sparse applications where a small Clifford operator is applied only on a particular subset of a larger stabilizer is also possible.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s = S\"Z_YX\";\n\njulia> apply!(s, CNOT, [4,2]) # Apply the CNOT on qubits 4 and 2\n+ ZXYX","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Pauli operators act as Clifford operators too (but they are rather boring, as they only change signs).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> P\"XII\" * S\"ZXX\"\n- ZXX","category":"page"},{"location":"manual/#Destabilizers","page":"Manual","title":"Destabilizers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Slightly abusing the name: What we call \"destabilizers\" here is a stabilizer and its destabilizing operators saved together. They are implemented with the Destabilizer object and are initialized from a stabilizer.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> s=S\"-XXX\n           -ZZI\n           +IZZ\";\n\njulia> d = Destabilizer(s)\n+ Z__\n+ X__\n+ _X_\n━━━━━\n- XXX\n- Z_Z\n+ _ZZ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"They have convenience methods to extract only the stabilizer and destabilizer pieces:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> stabilizerview(d)\n- XXX\n- Z_Z\n+ _ZZ\n\njulia> destabilizerview(d)\n+ Z__\n+ X__\n+ _X_","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Importantly commuting projections are much faster when tracking the destabilizer as canonicalization is not necessary (an mathcalO(n^2) complexity because it avoids the expensive mathcalO(n^3) canonicalization operation).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> project!(d,P\"ZZI\")\n(+ Z__\n+ X__\n+ _X_\n━━━━━\n- XXX\n- Z_Z\n+ _ZZ, 0, 0x02)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Non-commuting projections are just as fast as when using only stabilizers.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> project!(d,P\"ZZZ\")\n(- XXX\n+ _XX\n+ X_X\n━━━━━\n+ ZZZ\n- Z_Z\n+ _ZZ, 1, nothing)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Clifford operations can be applied the same way they are applied to stabilizers.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> apply!(d,CNOT⊗Hadamard)\n- X_Z\n+ _XZ\n+ XXZ\n━━━━━\n+ _ZX\n- Z_X\n+ ZZX","category":"page"},{"location":"manual/#Mixed-States","page":"Manual","title":"Mixed States","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Both the Stabilizer and Destabilizer structures have more general forms that enable work with mixed stabilizer states. They are the MixedStabilizer and MixedDestabilizer structures, described in Mixed States. More information that can be seen in the data structures page, which expands upon the algorithms available for each structure.","category":"page"},{"location":"canonicalization/#Canonicalization-operations","page":"Canonicalization","title":"Canonicalization operations","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Three different types of canonicalization operations are implemented.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"All of them are types of Gaussian elimination, with different choices for how to relate the X and Z components.","category":"page"},{"location":"canonicalization/#[canonicalize!](@ref)","page":"Canonicalization","title":"canonicalize!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"First do elimination on all X components and only then perform elimination on the Z components. Based on arxiv:1210.6646.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"julia> plot(canonicalize!(random_stabilizer(40,50)));","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"(Image: )","category":"page"},{"location":"canonicalization/#[canonicalize_rref!](@ref)","page":"Canonicalization","title":"canonicalize_rref!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"Cycle between elimination on X and Z for each qubit. Particularly useful for tracing out qubits. Based on arxiv:0505036.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"julia> plot(canonicalize_rref!(random_stabilizer(40,50),1:50)[1]; xzcomponents=:together);","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"(Image: )","category":"page"},{"location":"canonicalization/#[canonicalize_gott!](@ref)","page":"Canonicalization","title":"canonicalize_gott!","text":"","category":"section"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"First do elimination on all X components and only then perform elimination on the Z components, but without touching the qubits that were eliminated during the X pass. Particularly useful as certain blocks of the new created matrix are related to logical operations of the corresponding code. Based on Gottesman's thesis.","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"julia> plot(canonicalize_gott!(random_stabilizer(40,50))[1]; xzcomponents=:together);","category":"page"},{"location":"canonicalization/","page":"Canonicalization","title":"Canonicalization","text":"(Image: )","category":"page"},{"location":"noisycircuits_mc/#Monte-Carlo-simulations-of-noisy-Clifford-circuits","page":"Monte Carlo","title":"Monte Carlo simulations of noisy Clifford circuits","text":"","category":"section"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"DocTestSetup = quote\n    using QuantumClifford\n    using QuantumClifford.Experimental.NoisyCircuits\nend","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Import with using QuantumClifford.Experimental.NoisyCircuits.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"This module enables the simulation of noisy Clifford circuits through a Monte Carlo method where the same circuit is evaluated multiple times with random errors interspersed through it as prescribed by a given error model.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Here is an example of a purification circuit:","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"using QuantumClifford # hide\nusing QuantumClifford.Experimental.NoisyCircuits # hide\ngood_bell_state = S\"XX\n                    ZZ\"\ncanonicalize_rref!(good_bell_state)\ninitial_state = good_bell_state⊗good_bell_state\n\ng1 = SparseGate(CNOT, [1,3]) # CNOT between qubit 1 and qubit 3 (both with Alice)\ng2 = SparseGate(CNOT, [2,4]) # CNOT between qubit 2 and qubit 4 (both with Bob)\nm = BellMeasurement([X,X],[3,4]) # Bell measurement on qubit 3 and 4\nv = VerifyOp(good_bell_state,[1,2]) # Verify that qubit 1 and 2 indeed form a good Bell pair\nepsilon = 0.01 # The error rate\nn = NoiseOpAll(UnbiasedUncorrelatedNoise(epsilon))\n\n# This circuit performs a depolarization at rate `epsilon` to all qubits,\n# then bilater CNOT operations\n# then a Bell measurement\n# followed by checking whether the final result indeed corresponds to the correct Bell pair.\ncircuit = [n,g1,g2,m,v]\n\nmctrajectories(initial_state, circuit, trajectories=500)","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"For more examples, see the notebook comparing the Monte Carlo and Perturbative method.","category":"page"},{"location":"noisycircuits_mc/#Interface","page":"Monte Carlo","title":"Interface","text":"","category":"section"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"applyop!(s::Stabilizer, g::Operation)::Tuple{Stabilizer,Int} where the Int is the status of the operation. Predefined statuses are kept in the statuses dictionary:","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"const statuses = Dict(0=>:continue,\n                      1=>:detected_failure,\n                      2=>:undetected_failure,\n                      3=>:true_success)\nconst s_continue = 0\nconst s_detected_failure = 1\nconst s_undetected_failure = 2\nconst s_true_success = 3","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"Be sure to expand this dictionary if you want the trajectory simulators using your custom statuses to output all trajectories.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"TODO: We probably do not want to use this dictionary, rather a type/dispatch-based approach or symbols/namedtuple-based approach? Something to consider for a future version.","category":"page"},{"location":"noisycircuits_mc/","page":"Monte Carlo","title":"Monte Carlo","text":"There is also applynoise! which is convenient wait to create a noise model that can then be plugged into the NoisyGate, NoisyMeasurement, etc, letting you reuse the predefined perfect gates and measurements. However, you can also just make up your own noise operator simply by implementing applyop! for it.","category":"page"},{"location":"commonstates/#Useful-States-and-Operators","page":"Useful States and Operators","title":"Useful States and Operators","text":"","category":"section"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"DocTestSetup = quote\n    using QuantumClifford\n    using StableRNGs\n    rng = StableRNG(42)\nend","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"There are numerous frequently used stabilizer states already implemented in this library.","category":"page"},{"location":"commonstates/#Pauli-Operators","page":"Useful States and Operators","title":"Pauli Operators","text":"","category":"section"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"Single qubit PauliOperator is implemented in [single_z] and [single_x].","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"julia> single_z(4,2)\n+ _Z__\n\njulia> single_x(4,3)\n+ __X_","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"All identity operators use zero.","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"julia> zero(PauliOperator, 3)\n+ ___\n\njulia> zero(P\"XYZXYZ\")\n+ ______","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"Random Pauli operators are implemented as well (with or without a random phase).","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"julia> using StableRNGs; rng = StableRNG(42);\n\njulia> random_pauli(rng, 4)\n+i_ZZ_\n\njulia> random_pauli(rng, 4; nophase=true)\n+ ZXZY","category":"page"},{"location":"commonstates/#Stabilizer-States","page":"Useful States and Operators","title":"Stabilizer States","text":"","category":"section"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"An all-identity stabilizer can be created with zero.","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"julia> zero(Stabilizer, 3)\n+ ___\n+ ___\n+ ___\n\njulia> zero(Stabilizer, 2, 3)\n+ ___\n+ ___\n\njulia> zero(S\"XIZ\n              YZX\")\n+ ___\n+ ___","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"Diagonal stabilizers in different bases are available as well, through one.","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"julia> one(Stabilizer, 3)\n+ Z__\n+ _Z_\n+ __Z\n\njulia> one(Stabilizer, 3; basis=:Y)\n+ Y__\n+ _Y_\n+ __Y\n\njulia> one(S\"XX\n             ZZ\")\n+ Z_\n+ _Z","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"A random stabilizer can be created as well (consult the source code for exact ensemble, as there are caveats to the choice of distribution).","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"julia> random_stabilizer(rng, 2,5)\n- _ZY__\n+ ___X_","category":"page"},{"location":"commonstates/#Mixed-States","page":"Useful States and Operators","title":"Mixed States","text":"","category":"section"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"Similarly, one can create a diagonal mixed state.","category":"page"},{"location":"commonstates/","page":"Useful States and Operators","title":"Useful States and Operators","text":"julia> one(MixedDestabilizer, 2, 3)\nRank 2 stabilizer\n+ X__\n+ _X_\n━━━━━\n+ __X\n━━━━━\n+ Z__\n+ _Z_\n━━━━━\n+ __Z","category":"page"},{"location":"API/#Full-API-(autogenerated)","page":"API","title":"Full API (autogenerated)","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [QuantumClifford]","category":"page"},{"location":"API/#QuantumClifford.QuantumClifford","page":"API","title":"QuantumClifford.QuantumClifford","text":"A module for using the Stabilizer formalism and simulating Clifford circuits.\n\n\n\n\n\n","category":"module"},{"location":"API/#QuantumClifford.CliffordColumnForm","page":"API","title":"QuantumClifford.CliffordColumnForm","text":"An alternative representation of CliffordOperators.\n\nIt stores the columns of the operator in bitarrays (instead of the rows), permitting faster application, but complicating the tracking of phases.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.CliffordOperator","page":"API","title":"QuantumClifford.CliffordOperator","text":"Clifford Operator specified by the mapping of the basis generators.\n\njulia> CNOT\nX_ ⟼ + XX\n_X ⟼ + _X\nZ_ ⟼ + Z_\n_Z ⟼ + ZZ\n\njulia> phase_gate = C\"Y\n                      Z\"\nX ⟼ + Y\nZ ⟼ + Z\n\njulia> stab = S\"XI\n                IZ\";\n\njulia> entangled = CNOT*stab\n+ XX\n+ ZZ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Destabilizer","page":"API","title":"QuantumClifford.Destabilizer","text":"A tableau representation of a pure stabilizer state. The tableau tracks the destabilizers as well, for efficient projections. On initialization there are no checks that the provided state is indeed pure. This enables the use of this data structure for mixed stabilizer state, but a better choice would be to use MixedDestabilizer.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.MixedDestabilizer","page":"API","title":"QuantumClifford.MixedDestabilizer","text":"A tableau representation for mixed stabilizer states that keeps track of the destabilizers in order to provide efficient projection operations.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.MixedStabilizer","page":"API","title":"QuantumClifford.MixedStabilizer","text":"A slight improvement of the Stabilizer data structure that enables more naturally and completely the treatment of mixed states, in particular when the project! function is used.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.PauliOperator","page":"API","title":"QuantumClifford.PauliOperator","text":"A multi-qubit Pauli operator (1iIZXY^otimes n).\n\nA Pauli can be constructed with the P custom string macro or by building up one through products and tensor products of smaller operators.\n\njulia> pauli3 = P\"-iXYZ\"\n-iXYZ\n\njulia> pauli4 = 1im * pauli3 ⊗ X\n+ XYZX\n\njulia> Z*X\n+iY\n\nWe use a typical F(2,2) encoding internally. The X and Z bits are stored in a single concatenated padded array of UInt64 chunks of a bit array.\n\njulia> p = P\"-IZXY\";\n\njulia> p.xz\n2-element Array{UInt64,1}:\n 0x000000000000000c\n 0x000000000000000a\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.Stabilizer","page":"API","title":"QuantumClifford.Stabilizer","text":"Stabilizer, i.e. a list of commuting multi-qubit Hermitian Pauli operators.\n\nInstances can be created with the S custom string macro or as direct sum of other stabilizers.\n\njulia> s = S\"XXX\n             ZZI\n             IZZ\"\n+ XXX\n+ ZZ_\n+ _ZZ\n\njulia> s⊗s\n+ XXX___\n+ ZZ____\n+ _ZZ___\n+ ___XXX\n+ ___ZZ_\n+ ____ZZ\n\nIt has an indexing API, looking like a list of PauliOperators.\n\njulia> s[2]\n+ ZZ_\n\nPauli operators can act directly on the a stabilizer.\n\njulia> P\"YYY\" * s\n- XXX\n+ ZZ_\n+ _ZZ\n\nThere are no automatic checks for correctness (i.e. independence of all rows, commutativity of all rows, hermiticity of all rows). The rank (number of rows) is permitted to be less than the number of qubits (number of columns): canonilization, projection, etc. continue working in that case. To great extent this library uses the Stabilizer data structure simply as a tableau. This might be properly abstracted away in future versions.\n\nSee also: PauliOperator, canonicalize!\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumClifford.canonicalize!-Tuple{Stabilizer}","page":"API","title":"QuantumClifford.canonicalize!","text":"Canonicalize a stabilizer (in place).\n\nAssumes the input is a valid stabilizer (all operators commute and have real phases). It permits redundant generators and identity generators.\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(S\"XXXX\n                       IZZI\n                       IIZZ\")\n+ XXXX\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(S\"XXXX\n                       ZZII\n                       IZZI\n                       IZIZ\n                       IIZZ\")\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n+ ____\n\nBased on arxiv:1210.6646. See arxiv:0505036 for other types of canonicalization.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.canonicalize_rref!-Union{Tuple{T}, Tuple{QuantumClifford.AbstractStabilizer,AbstractArray{T,1}}} where T<:Integer","page":"API","title":"QuantumClifford.canonicalize_rref!","text":"Canonicalize a stabilizer (in place) along only some columns.\n\nThis uses different canonical form from canonicalize!. It also indexes in reverse in order to make its use in traceout! more efficient.\n\nBased on arxiv:0505036.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.comm-Tuple{AbstractArray{UInt64,1},AbstractArray{UInt64,1}}","page":"API","title":"QuantumClifford.comm","text":"Check whether two operators commute.\n\n0x0 if they commute, 0x1 if they anticommute.\n\njulia> P\"XX\"*P\"ZZ\", P\"ZZ\"*P\"XX\"\n(- YY, - YY)\n\njulia> comm(P\"ZZ\", P\"XX\")\n0x00\n\njulia> comm(P\"IZ\", P\"XX\")\n0x01\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.destab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.destab_looks_good","text":"Check basic consistency requirements of a destabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.generate!-Tuple{PauliOperator,Stabilizer}","page":"API","title":"QuantumClifford.generate!","text":"Generate a Pauli operator by using operators from a given the Stabilizer.\n\nIt assumes the stabilizer is already canonicalized. It modifies the Pauli operator in place. It assumes the operator can be generated up to a phase. That phase is left in the modified operator, which should be the identity up to a phase. Returns the new operator and the list of indices denoting the elements of stabilizer that were used for the generation.\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> generate!(P\"-ZIZI\", ghz)\n(- ____, [2, 4])\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mixed_destab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.mixed_destab_looks_good","text":"Check basic consistency requirements of a mixed destabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.mixed_stab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.mixed_stab_looks_good","text":"Check basic consistency requirements of a mixed stabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.prodphase-Tuple{AbstractArray{UInt64,1},AbstractArray{UInt64,1}}","page":"API","title":"QuantumClifford.prodphase","text":"Get the phase of the product of two Pauli operators.\n\nPhase is encoded as F(4) in the low qubits of an UInt8.\n\njulia> P\"ZZZ\"*P\"XXX\"\n-iYYY\n\njulia> prodphase(P\"ZZZ\", P\"XXX\")\n0x03\n\njulia> prodphase(P\"XXX\", P\"ZZZ\")\n0x01\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.project!-Tuple{Stabilizer,PauliOperator}","page":"API","title":"QuantumClifford.project!","text":"Project the state of a Stabilizer on the two eigenspaces of a Pauli operator.\n\nAssumes the input is a valid stabilizer. The projection is done inplace on that stabilizer and it does not modify the projection operator.\n\nIt returns\n\na stabilizer that might not be in canonical form\nthe index of the row where the non-commuting operator was (that row is now equal to pauli; its phase is not updated and for a faithful measurement simulation it needs to be randomized by the user)\nand the result of the projection if there was no non-cummuting operator (nothing otherwise)\n\nIf keep_result==false that result of the projection in case of anticommutation is not computed, sparing a canonicalization operation.\n\nHere is an example of a projection destroing entanglement:\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> state, anticom_index, result = project!(ghz, P\"ZIII\");\n\njulia> state\n+ Z___\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(state)\n+ Z___\n+ _Z__\n+ __Z_\n+ ___Z\n\njulia> anticom_index, result\n(1, nothing)\n\nAnd an example of projection consistent with the stabilizer state.\n\njulia> s = S\"ZII\n             IXI\n             IIY\";\n\njulia> canonicalize!(s)\n+ _X_\n+ __Y\n+ Z__\n\njulia> state, anticom_index, result = project!(s, P\"-ZII\");\n\njulia> state\n+ _X_\n+ __Y\n+ Z__\n\njulia> anticom_index, result\n(0, 0x02)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.stab_looks_good-Tuple{Any}","page":"API","title":"QuantumClifford.stab_looks_good","text":"Check basic consistency requirements of a stabilizer. Used in tests.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumClifford.traceout!-Union{Tuple{T}, Tuple{Stabilizer,AbstractArray{T,1}}} where T<:Integer","page":"API","title":"QuantumClifford.traceout!","text":"Trace out a qubit.\n\n\n\n\n\n","category":"method"},{"location":"mixed/#Mixed-Stabilizer-States","page":"Mixed States","title":"Mixed Stabilizer States","text":"","category":"section"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"DocTestSetup = quote\n    using QuantumClifford\nend","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"The Stabilizer and Destabilizer have some support for mixed states (by being initialized with an incomplete list of stabilizer generators), but for most purposes one would use the Mixed* data structures.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Mixed stabilizer states are implemented with MixedStabilizer and MixedDestabilizer, the latter of which is the preferred data structure for most tasks as it is much faster by virtue of tracking the destabilizer generators.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> s = S\"XXX\n             IZZ\";\n\njulia> Destabilizer(s)\n+ Z__\n+ _X_\n━━━━━\n+ XXX\n+ _ZZ","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Unlike Destabilizer, MixedDestabilizer also tracks the logical operation generators.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> m = MixedDestabilizer(s)\nRank 2 stabilizer\n+ Z__\n+ _X_\n━━━━━\n+ _XX\n━━━━━\n+ XXX\n+ _ZZ\n━━━━━\n+ Z_Z\n\njulia> stabilizerview(m)\n+ XXX\n+ _ZZ\n\njulia> destabilizerview(m)\n+ Z__\n+ _X_\n\njulia> logicalxview(m)\n+ _XX\n\njulia> logicalzview(m)\n+ Z_Z","category":"page"},{"location":"mixed/#Gottesman-Canonicalization","page":"Mixed States","title":"Gottesman Canonicalization","text":"","category":"section"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"To obtain the logical operators we perform a different type of canonicalization, described in Gottesman's thesis and implemented in canonicalize_gott!. Unlike canonicalize! which uses only row operations, canonicalize_gott! performs column swaps as well. MixedDestabilizer undoes those swaps by default when instantiated, but that behavior can be turned off, if you prefer to work with the canonicalized tableau.","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"julia> s = S\"XXX\n             ZIZ\";\n\njulia> MixedDestabilizer(s)\nRank 2 stabilizer\n+ Z__\n+ __X\n━━━━━\n+ _X_\n━━━━━\n+ XXX\n+ Z_Z\n━━━━━\n+ ZZ_\n\njulia> MixedDestabilizer(s; undoperm=false)\nRank 2 stabilizer\n+ Z__\n+ _X_\n━━━━━\n+ __X\n━━━━━\n+ XXX\n+ ZZ_\n━━━━━\n+ Z_Z","category":"page"},{"location":"mixed/","page":"Mixed States","title":"Mixed States","text":"Destabilizer and MixedStabilizer do not use any column swaps on instantiation as they do not track the logical operators.","category":"page"},{"location":"datastructures/#Choosing-Appropriate-Data-Structure","page":"Datastructure Choice","title":"Choosing Appropriate Data Structure","text":"","category":"section"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"There are four different data structures used to represent stabilizer states. If you will never need projective measurements you probably would want to use Stabilizer. If you require projective measurements, but only on pure states, Destabilizer should be the appropriate data structure. If mixed stabilizer states are involved, MixedStabilizer would be necessary.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Stabilizer is simply a list of Pauli operators in a tableau form. As a data structure it does not enforce the requirements for a pure stabilizer state (the rows of the tableau do not necessarily commute, nor are they forced to be Hermitian; the tableau might be underdetermined, redundant, or contradictory). It is up to the user to ensure that the initial values in the tableau are meaningful and consistent.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"canonicalize!, project!, and generate! can accept an under determined (mixed state) Stabilizer instance and operate correctly. canonicalize! can also accept a redundant Stabilizer (i.e. not all rows are independent), leaving as many identity rows at the bottom of the canonicalized tableau as the number of redundant stabilizers in the initial tableau.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"canonicalize! takes mathcalO(n^3) steps. generate! expects a canonicalized input and then takes mathcalO(n^2) steps. project! takes mathcalO(n^3) for projecting on commuting operators due to the need to call canonicalize! and generate!. If the projections is on an anticommuting operator (or if keep_result=false) then it takes mathcalO(n^2) steps.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"MixedStabilizer provides explicit tracking of the rank of the mixed state and works properly when the projection is on a commuting operator not in the stabilizer (see table below for details). Otherwise it has the same performance as Stabilizer.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"The canonicalization can be made unnecessary if we track the destabilizer generators. There are two data structures capable of that.","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"Destabilizer stores both the destabilizer and stabilizer states. project! called on it never requires a stabilizer canonicalization, hence it runs in mathcalO(n^2). However, project! will raise an exception if you try to project on a commuting state that is not in the stabilizer as that would be an expensive operation (mathcalO(n^3)).","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"MixedDestabilizer tracks both the destabilizer operators and the logical operators in addition to the stabilizer generators. It does not require canonicalization for measurements and its project! operations always takes mathcalO(n^3).","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"projection Stabilizer MixedStabilizer Destabilizer MixedDestabilizer\non anticommuting operator correct result in mathcalO(n^2) steps same as Stabilizer same as Stabilizer same as Stabilizer\non commuting operator in the stabilizer mathcalO(n^3), or mathcalO(n^2) if keep_result=false mathcalO(n^3) mathcalO(n^2) if the state is pure, throws exception otherwise mathcalO(n^2)\non commuting operator out of the stabilizer[1] mathcalO(n^3), but the user needs to manually include the new operator to the stabilizer mathcalO(n^3) not applicable if the state is pure, throws an error otherwise mathcalO(n^3)","category":"page"},{"location":"datastructures/","page":"Datastructure Choice","title":"Datastructure Choice","text":"[1]: This can occur only if the state being projected is mixed. Both Stabilizer and Destabilizer can be used for mixed states by simply providing fewer stabilizer generators than qubits at initialization. This can be useful for low-level code that tries to avoid the extra memory cost of using MixedStabilizer and MixedDestabilizer but should be avoided otherwise. project! works correctly or raises an explicit warning on all 4 data structures.","category":"page"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Stabilizers have a plot recipe that can be used with Plots.jl. It simply displays the corresponding parity check matrix (extracted with stab_to_gf2) as a bitmap image.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Random; Random.seed!(1); using Plots; using QuantumClifford\nplot(random_stabilizer(40,50));\nsavefig(\"plot-randstab.png\"); nothing","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"julia> plot(random_stabilizer(40,50));","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Random; Random.seed!(1); using Plots; using QuantumClifford\nplot(canonicalize!(random_stabilizer(40,50)));\nsavefig(\"plot-canostab.png\"); nothing","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"julia> plot(canonicalize!(random_stabilizer(40,50)));","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Random; Random.seed!(1); using Plots; using QuantumClifford\nplot(canonicalize_gott!(random_stabilizer(40,50))[1]);\nsavefig(\"plot-gottstab.png\"); nothing","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"julia> plot(canonicalize_gott!(random_stabilizer(40,50))[1]);","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Random; Random.seed!(1); using Plots; using QuantumClifford\nplot(canonicalize_gott!(random_stabilizer(40,50))[1]; xzcomponents=:together);\nsavefig(\"plot-gottstab-together.png\"); nothing","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"julia> plot(canonicalize_gott!(random_stabilizer(40,50))[1]; xzcomponents=:together);","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Random; Random.seed!(1); using Plots; using QuantumClifford\nplot(canonicalize_rref!(random_stabilizer(40,50),1:50)[1]; xzcomponents=:together);\nsavefig(\"plot-rref-together.png\"); nothing","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"julia> plot(canonicalize_rref!(random_stabilizer(40,50),1:50)[1]; xzcomponents=:together);","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: )","category":"page"},{"location":"#QuantumClifford.jl","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"","category":"section"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"DocTestSetup = quote\n    using QuantumClifford\nend","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"A Julia package for working with quantum stabilizer states and Clifford circuits that act on them.","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"Works efficiently with pure and mixed stabilizer states of thousands of qubits as well as sparse or dense Clifford operations acting upon them.","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"Provides canonicalization, projection, and generation operations, as well as partial traces.","category":"page"},{"location":"","page":"QuantumClifford.jl","title":"QuantumClifford.jl","text":"julia> P\"X\" * P\"Z\"\n-iY\n\njulia> P\"X\" ⊗ P\"Z\"\n+ XZ\n\njulia> S\"-XX\n         +ZZ\"\n- XX\n+ ZZ\n\njulia> CNOT * S\"-XX\n                +ZZ\"\n- X_\n+ _Z","category":"page"}]
}
