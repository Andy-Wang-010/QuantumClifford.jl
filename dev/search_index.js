var documenterSearchIndex = {"docs":
[{"location":"#SimpleClifford.jl-1","page":"SimpleClifford.jl","title":"SimpleClifford.jl","text":"","category":"section"},{"location":"#","page":"SimpleClifford.jl","title":"SimpleClifford.jl","text":"Documentation for SimpleClifford.jl","category":"page"},{"location":"#","page":"SimpleClifford.jl","title":"SimpleClifford.jl","text":"DocTestSetup  = quote\n    using SimpleClifford\nend","category":"page"},{"location":"#","page":"SimpleClifford.jl","title":"SimpleClifford.jl","text":"Modules = [SimpleClifford]","category":"page"},{"location":"#SimpleClifford.SimpleClifford","page":"SimpleClifford.jl","title":"SimpleClifford.SimpleClifford","text":"A module for simulation of Clifford circuits.\n\n\n\n\n\n","category":"module"},{"location":"#SimpleClifford.CliffordOperator","page":"SimpleClifford.jl","title":"SimpleClifford.CliffordOperator","text":"Clifford Operator specified by the mapping of the basis generators.\n\njulia> CNOT\nX_ ⟼ + XX\n_X ⟼ + _X\nZ_ ⟼ + Z_\n_Z ⟼ + ZZ\n\njulia> phase_gate = C\"Y\n                      Z\"\nX ⟼ + Y\nZ ⟼ + Z\n\njulia> stab = S\"XI\n                IZ\";\n\njulia> entangled = CNOT*stab\n+ XX\n+ ZZ\n\n\n\n\n\n","category":"type"},{"location":"#SimpleClifford.PauliOperator","page":"SimpleClifford.jl","title":"SimpleClifford.PauliOperator","text":"A multi-qubit Pauli operator (1iIZXY^otimes n).\n\nA Pauli can be constructed with the P custom string macro or by building up one through products and tensor products of smaller operators.\n\njulia> pauli3 = P\"-iXYZ\"\n-iXYZ\n\njulia> pauli4 = 1im * pauli3 ⊗ X\n+ XYZX\n\njulia> Z*X\n+iY\n\nWe use a typical F(2,2) encoding internally. The X and Z bits are stored in a single concatenated padded array of UInt64 chunks of a bit array.\n\njulia> p = P\"-IZXY\";\n\njulia> p.xz\n2-element Array{UInt64,1}:\n 0x000000000000000c\n 0x000000000000000a\n\n\n\n\n\n","category":"type"},{"location":"#SimpleClifford.Stabilizer","page":"SimpleClifford.jl","title":"SimpleClifford.Stabilizer","text":"Stabilizer, i.e. a list of commuting multi-qubit Hermitian Pauli operators.\n\nInstances can be created with the S custom string macro or as direct sum of other stabilizers.\n\njulia> s = S\"XXX\n             ZZI\n             IZZ\"\n+ XXX\n+ ZZ_\n+ _ZZ\n\njulia> s⊕s\n+ XXX___\n+ ZZ____\n+ _ZZ___\n+ ___XXX\n+ ___ZZ_\n+ ____ZZ\n\nIt has an indexing API, looking like a list of PauliOperators.\n\njulia> s[2]\n+ ZZ_\n\nPauli operators can act directly on the a stabilizer.\n\njulia> P\"YYY\" * s\n- XXX\n+ ZZ_\n+ _ZZ\n\nThere are no automatic checks for correctness (i.e. independence of all rows, commutativity of all rows, hermiticity of all rows). The rank (number of rows) is permitted to be less than the number of qubits (number of columns): canonilization, projection, etc. continue working in that case.\n\nSee also: PauliOperator, canonicalize!\n\n\n\n\n\n","category":"type"},{"location":"#SimpleClifford.canonicalize!-Tuple{Stabilizer}","page":"SimpleClifford.jl","title":"SimpleClifford.canonicalize!","text":"Canonicalize a stabilizer (in place).\n\nAssumes the input is a valid stabilizer (all operators commute and have real phases). It permits redundant generators and identity generators.\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(S\"XXXX\n                       IZZI\n                       IIZZ\")\n+ XXXX\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(S\"XXXX\n                       ZZII\n                       IZZI\n                       IZIZ\n                       IIZZ\")\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n+ ____\n\nBased on arxiv:1210.6646. See arxiv:0505036 for other types of canonicalization.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleClifford.comm-Tuple{PauliOperator,PauliOperator}","page":"SimpleClifford.jl","title":"SimpleClifford.comm","text":"Check whether two operators commute.\n\n0x0 if they commute, 0x1 if they anticommute.\n\njulia> P\"XX\"*P\"ZZ\", P\"ZZ\"*P\"XX\"\n(- YY, - YY)\n\njulia> comm(P\"ZZ\", P\"XX\")\n0x00\n\njulia> comm(P\"IZ\", P\"XX\")\n0x01\n\n\n\n\n\n","category":"method"},{"location":"#SimpleClifford.generate!-Tuple{PauliOperator,Stabilizer}","page":"SimpleClifford.jl","title":"SimpleClifford.generate!","text":"Generate a Pauli operator by using operators from a given the Stabilizer.\n\nIt assumes the stabilizer is already canonicalized. It modifies the Pauli operator in place. It assumes the operator can be generated up to a phase. That phase is left in the modified operator, which should be the identity up to a phase. Returns the new operator and the list of indices denoting the elements of stabilizer that were used for the generation.\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> generate!(P\"-ZIZI\", ghz)\n(- ____, [2, 4])\n\n\n\n\n\n","category":"method"},{"location":"#SimpleClifford.prodphase-Tuple{AbstractArray{UInt64,1},AbstractArray{UInt64,1}}","page":"SimpleClifford.jl","title":"SimpleClifford.prodphase","text":"Get the phase of the product of two Pauli operators.\n\nPhase is encoded as F(4) in the low qubits of an UInt8.\n\njulia> P\"ZZZ\"*P\"XXX\"\n-iYYY\n\njulia> prodphase(P\"ZZZ\", P\"XXX\")\n0x03\n\njulia> prodphase(P\"XXX\", P\"ZZZ\")\n0x01\n\n\n\n\n\n","category":"method"},{"location":"#SimpleClifford.project!-Tuple{Stabilizer,PauliOperator}","page":"SimpleClifford.jl","title":"SimpleClifford.project!","text":"Project the state of a Stabilizer on the two eigenspaces of a Pauli operator.\n\nAssumes the input is a valid stabilizer. The projection is done inplace on that stabilizer and it does not modify the projection operator.\n\nIt returns\n\na stabilizer that might not be in canonical form\nthe index of the row where the non-commuting operator was (that row is now equal to pauli; its phase is not updated and for a faithful measurement simulation it needs to be randomized by the user)\nand the result of the projection if there was no non-cummuting operator (nothing otherwise)\n\nIf keep_result==false that result of the projection in case of anticommutation is not computed, sparing a canonicalization operation.\n\nHere is an example of a projection destroing entanglement:\n\njulia> ghz = S\"XXXX\n               ZZII\n               IZZI\n               IIZZ\";\n\njulia> canonicalize!(ghz)\n+ XXXX\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> state, anticom_index, result = project!(ghz, P\"ZIII\");\n\njulia> state\n+ Z___\n+ Z__Z\n+ _Z_Z\n+ __ZZ\n\njulia> canonicalize!(state)\n+ Z___\n+ _Z__\n+ __Z_\n+ ___Z\n\njulia> anticom_index, result\n(1, nothing)\n\nAnd an example of projection consistent with the stabilizer state.\n\njulia> s = S\"ZII\n             IXI\n             IIY\";\n\njulia> canonicalize!(s)\n+ _X_\n+ __Y\n+ Z__\n\njulia> state, anticom_index, result = project!(s, P\"-ZII\");\n\njulia> state\n+ _X_\n+ __Y\n+ Z__\n\njulia> anticom_index, result\n(0, 0x02)\n\n\n\n\n\n","category":"method"}]
}
